
<!DOCTYPE html>

<html>
<head><meta content="noindex,nofollow" name="robots"/>
<title>Abstract Type Members versus Generic Type Parameters in Scala</title>
<meta charset="utf-8"/>
<meta content="Bill Venners" name="author">
<link href="../_/https/www.artima.com/artima.css" rel="stylesheet" type="text/css"/>
<link href="../_/https/www.artima.com/favicon.ico" rel="shortcut icon"/>
</meta></head>
<body><table cellspacing="0" width="100%">
<tr>
<td align="left" valign="bottom">
<a href="../_/https/www.artima.com/index.html"><img alt="The Artima Developer Community" border="0" height="43" src="../_/https/www.artima.com/images/a7.gif" width="550"/></a>
</td>
</tr></table>
<table bgcolor="#333333" width="100%">
<tr>
<td align="center">
<div class="ml">
<a class="hl" href="../_/https/www.artima.com/articles/index.html">Articles</a> |
<a class="hl" href="../_/https/www.artima.com/news/index.html">News</a> |
<a class="hl" href="../index.html">Weblogs</a> |
<a class="hl" href="../_/https/www.artima.com/shop/catalog/index.html">Books</a> |
<a class="hl" href="../_/https/www.artima.com/forums/index.html">Forums</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#D3D3D3" width="100%">
<tr>
<td align="center">
<div class="sc">
<a href="../index.html">Artima Weblogs</a> | 

<a href="../index.html$/blogger=bv.html">Bill Venners' Weblog</a> | 

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=270195.html">Discuss</a> | 
<a href="mailto:?subject=Abstract Type Members versus Generic Type Parameters in Scala&amp;body= %0AArtima Weblogs %0AAbstract Type Members versus Generic Type Parameters in Scala %0Aby Bill Venners %0A%0Ahttps://www.artima.com/weblogs/viewpost.jsp?thread=270195">Email</a> | 
<a href="../viewpostP.html$/thread=270195.html">Print</a> | 
<a href="../bloggers.html">Bloggers</a> | 
<a class="sl" href="thread=268689.html" title="Josh Bloch on the Semantic Gap">Previous</a> | 
<a class="sl" href="thread=272118.html" title="What are Your JUnit Pain Points, Really?">Next</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#EEEEEE" width="100%">
<tr>
<td align="center">
<div class="sc">
<span style="color: #555555;">Sponsored Link</span> <span style="color: #888888;">•</span>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a799ecf6.html" target="_top"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:9&amp;n=a0587811.html"/></a></noscript>
</div>
</td>
</tr>
</table>
<br/>
<div class="vegies">
<div class="tc">
<span class="sts">Angle Brackets and Curly Braces</span><br>
<span class="ts">Abstract Type Members versus Generic Type Parameters in Scala</span><br/>
<span class="as">by Bill Venners</span><br/>
<span class="pd">October 7, 2009</span><br/>
</br></div>
<blockquote>
<b>Summary</b><br/>
In this blog, I attempt to answer a common question among Scala programmers: when would I opt to use an abstract type member instead of a generic type parameter in Scala API design?

</blockquote>
<hr align="left" width="90%"/>
<table align="right">
<tr>
<td>
<div class="adnotice">
Advertisement
</div>
<center>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
if (!document.phpAds_used) document.phpAds_used = ',';
phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
document.write ("&amp;what=zone:2");
document.write ("&amp;exclude=" + document.phpAds_used);
if (document.referrer)
document.write ("&amp;referer=" + escape(document.referrer));
document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a74ab060.html" target="_blank"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:2&amp;n=a74ab060.html"/></a></noscript>
</center>
</td>
</tr>
</table>
<p>
<p>
A common question asked by people learning Scala is how to decide between 
abstract type members and generic type parameters when you need to model an abstract type. For those
unfamiliar with the difference, type parameters in Scala are similar to type parameters in Java, except instead of
Java's angle brackets:
</p>
<pre>
interface Collection&lt;T&gt; {
    // ...
}
</pre>
<p>
Scala uses square brackets:
</p>
<pre>
// Type parameter version
trait Collection[T] {
  // ...
}
</pre>
<p>
Abstract type members in Scala have no equivalent in Java. In both languages, classes, interfaces (in Java), and traits (in Scala) can have
methods and fields as members. In Scala, a class or trait can also have type members, and just as methods can be abstract in Java, methods
fields, and types can all be abstract in Scala. Here's how an abstract type member looks in Scala:
</p>
<pre>
// Type member version
trait Collection {
  type T
  // ...
}
</pre>
<p>
In both cases, the abstract type can be made concrete in a subtype. Here's a subtype of the type parameter version of <code>Collection</code> that
specifies the concrete type <code>String</code> for <code>T</code>:
</p>
<pre>
// Type parameter version
trait StringCollection extends Collection[String] {
  // ...
}
</pre>
<p>
Here's a subtype of the type member version of <code>Collection</code> that also
specifies the concrete type <code>String</code> for <code>T</code>:
</p>
<pre>
// Type member version
trait StringCollection extends Collection {
  type T = String
  // ...
}
</pre>
<p>
This seems to be, and in fact is, two different ways to achieve the same goal. So when would you choose one over the other?
I asked Martin Odersky this question <a href="../_/http/www.artima.com/scalazine/articles/scalas_type_system.html#abstracttypes">in an interview</a>. He first 
explained that one reason for having both abstract type members and generic type parameters is orthogonality:
</p>
<blockquote>
<p>
There have always been two notions of abstraction: parameterization and abstract members. In Java you also have both, but it depends on what you are abstracting over. In Java you have abstract methods, but you can't pass a method as a parameter. You don't have abstract fields, but you can pass a value as a parameter. And similarly you don't have abstract type members, but you can specify a type as a parameter. So in Java you also have all three of these, but there's a distinction about what abstraction principle you can use for what kinds of things. And you could argue that this distinction is fairly arbitrary.
</p>
<p>
What we did in Scala was try to be more complete and orthogonal. We decided to have the same construction principles for all three sorts of members. So you can have abstract fields as well as value parameters. You can pass methods (or "functions") as parameters, or you can abstract over them. You can specify types as parameters, or you can abstract over them. And what we get conceptually is that we can model one in terms of the other. At least in principle, we can express every sort of parameterization as a form of object-oriented abstraction. So in a sense you could say Scala is a more orthogonal and complete language.
</p>
</blockquote>
<p>
He also described a difference between abstract type members and generic type parameters that can show up in practice:
</p>
<blockquote>
<p>
But in practice, when you [use type parameterization] with many different things, it leads to an explosion of parameters, and usually, what's more, in bounds of parameters. At the 1998 ECOOP, Kim Bruce, Phil Wadler, and I had a paper where we showed that as you increase the number of things you don't know, the typical program will grow quadratically. So there are very good reasons not to do parameters, but to have these abstract members, because they don't give you this quadratic blow up.
</p>
</blockquote>
<p>
When he gave this answer, I wasn't sure I understood exactly what he was talking about, but I think I can now offer some more insight into this difference.
I have tended to use generic type parameters by default, perhaps because I come from a C++ and Java background and are more familiar with type
parameterization than type members. However, I have encountered one design problem
that I ended up solving with abstract type members, not generic type parameters.
</p>
<p>
The problem was that I wanted to provide traits in ScalaTest that allow users to write tests into which they can pass fixture objects.
This would give people the option of writing tests in a functional style instead of the traditional imperative style of JUnit's <code>setUp</code>
and <code>tearDown</code> methods. To provide this option, I needed to allow users to indicate the type of the fixture object by
either specifying a concrete type parameter or member. In other words, I'd either provide this trait in the ScalaTest API:
</p>
<pre>
// Type parameter version
trait FixtureSuite[F] {
  // ...
}
</pre>
<p>
Or this one:
</p>
<pre>
// Type member version
trait FixtureSuite {
  type F
  // ...
}
</pre>
<p>
In either case, <code>F</code> would be the type of the fixture parameter to pass into the tests, which suite subclasses would make concrete.
Here's an example of a concrete suite of tests that needs a <code>StringBuilder</code> passed into each test, using the type parameter approach:
</p>
<pre>
// Type parameter version
class MySuite extends FixtureSuite[StringBuilder] {
  // ...
}
</pre>
<p>
And here's an example of a concrete suite of tests that needs a <code>StringBuilder</code> passed into each test using the abstract type member approach:
</p>
<pre>
// Type member version
class MySuite extends FixtureSuite {
  type F = StringBuilder
  // ...
}
</pre>
<p>
So far there's not much difference. However, one other use case I had is that I wanted to allow people to create traits that provide a concrete definition for the fixture type and could be mixed into suite classes. This would allow users to encode commonly used fixtures into helper traits that could be mixed
into any of their suite classes that need them. This is where a difference showed up. Here's how you'd write that trait using the generic type
parameter approach:
</p>
<pre>
// Type parameter version
trait StringBuilderFixture { this: FixtureSuite[StringBuilder] =&gt;
  // ...
}
</pre>
<p>
The "<code>this: FixtureSuite[StringBuilder]</code>" syntax is a <em>self type</em>, which indicates that trait <code>StringBuilderFixture</code>
can only be mixed into a <code>FixtureSuite[StringBuilder]</code>. By contrast, here's what this trait would look like when
taking the type member approach:
</p>
<pre>
// Type member version
trait StringBuilderFixture { this: FixtureSuite =&gt;
  type F = StringBuilder
  // ...
}
</pre>
<p>
So far there's still only cosmetic differences, but the pain point of the type member approach is about to arise. As soon as a user tries
to mix the <code>StringBuilderFixture</code> into a suite class, you'll see a usability difference. In the type parameter approach, the user
must repeat the type parameter even though it is defined in the trait:
</p>
<pre>
// Type parameter version
class MySuite extends FixtureSuite[StringBuilder] with StringBuilderFixture {
  // ...
}
</pre>
<p>
But in the abstract type member approach, no such repetition is necessary:
</p>
<pre>
// Type member version
class MySuite extends FixtureSuite with StringBuilderFixture {
  // ...
}
</pre>
<p>
Because of this difference, I chose to model the fixture parameter type as an abstract type member, not a generic type parameter, in ScalaTest.
I named the type member <code>FixtureParam</code>, to make it more obvious to readers of the code what the type is used for.
(This feature is in ScalaTest 1.0. For the details, check out the scaladoc documentation of
trait <a href="../_/http/www.artima.com/scalatest/doc-1.0-RC1/org/scalatest/fixture/FixtureSuite.html"><code>FixtureSuite</code></a>.) In a future
release of ScalaTest, I plan to add new traits that allow multiple fixture
objects to be passed into tests. For example, if you want to pass three different fixture objects into tests, you'll be able to do so, but 
you'll need to specify three types, one for each parameter. Thus had I taken the
type parameter approach, your suite classes could have ended up looking like this:
</p>
<pre>
// Type parameter version
class MySuite extends FixtureSuite3[StringBuilder, ListBuffer, Stack] with MyHandyFixture {
  // ...
}
</pre>
<p>
Whereas with the type member approach it will look like this:
</p>
<pre>
// Type member version
class MySuite extends FixtureSuite3 with MyHandyFixture {
  // ...
}
</pre>
<p>
One other minor difference between abstract type members and generic type parameters is that when a generic type parameter is
specified, readers of the code do not see the name of the type parameter. Thus were someone to see this line of code:
</p>
<pre>
// Type parameter version
class MySuite extends FixtureSuite[StringBuilder] with StringBuilderFixture {
  // ...
}
</pre>
<p>
They wouldn't know what the name of the type parameter specified as <code>StringBuilder</code> was without looking it up.
Whereas the name of the type parameter is right there in the code in the abstract type member approach:
</p>
<pre>
// Type member version
class MySuite extends FixtureSuite with StringBuilderFixture {
  type FixtureParam = StringBuilder
  // ...
}
</pre>
<p>
In the latter case, readers of the code could see that <code>StringBuilder</code> is the "fixture parameter" type. They still
would need to figure out what "fixture parameter" meant, but they could at least get the name of the type without looking 
in the documentation. I think there will be design situations where the explicit type member name will be better, and situations where it is worse. I think having the <code>FixtureParam</code> name explicit in ScalaTest <code>FixtureSuite</code>s helps the readability of the code. But I wouldn't want to have to do that for collections. I like saying <code>new ListBuffer[String]</code>, and am glad I don't have to say <code>new ListBuffer { type E = String }</code>.
</p>
<p>
My observation so far about abstract type members is that they are primarily a better choice than generic type parameters when you want to let people mix in definitions of those types via traits. You may also want to consider using them when you think the explicit mention of the type member name when it is being defined will help code readability.
</p>
<p>
What do you think of this take on abstract type members in Scala? Do you have any other insights about the abstract-type-member-versus-generic-type-parameter question to share?
</p>
<h1>Talk Back!</h1>
<p>
Have an opinion?


Readers have already posted

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=270195.html">12

comments</a>
about this weblog entry. Why not

<a href="../_/https/www.artima.com/forums/post.html$/forum=106&amp;thread=270195&amp;reply=true.html">add yours</a>?


<h1>RSS Feed</h1>
<p>
If you'd like to be notified whenever Bill Venners adds a new entry to <a href="../index.html$/blogger=bv.html">his weblog</a>, subscribe to his <a href="../feeds/bloggers/bv.rss">RSS feed</a>.

<center>
<div class="sociallinks">
<a href="../_/http/digg.com/submit$/phase=2&amp;url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D270195&amp;title=Abstract+Type+Members+versus+Generic+Type+Parameters+in+Scala&amp;bodytext=In+this+blog%2C+I+attempt+to+answer+a+common+question+among+Scala+programmers%3A+when+would+I+opt+to+use+an+abstract+type+member+instead+of+a+generic+type+parameter+in+Scala+API+design%3F&amp;topic=programming">
<img alt="Digg" border="0" height="14" hspace="8" src="../_/https/www.artima.com/images/digg.gif" width="16">Digg
  </img></a>
  |
  <a href="../_/http/del.icio.us/post$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D270195&amp;title=Abstract+Type+Members+versus+Generic+Type+Parameters+in+Scala">
<img alt="del.icio.us" border="0" height="16" hspace="8" src="../_/https/www.artima.com/images/delicious.gif" vspace="1" width="16">del.icio.us
  </img></a>
  |
  <a href="../_/http/programming.reddit.com/submit$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D270195&amp;title=Abstract+Type+Members+versus+Generic+Type+Parameters+in+Scala">
<img alt="Reddit" border="0" height="18" hspace="8" src="../_/https/www.artima.com/images/reddit.gif" width="18"/>Reddit
  </a>
</div>
</center>
<h1>About the Blogger</h1>
<p>
<table><tr valign="bottom"><td><img align="right" src="../_/https/www.artima.com/images/bv.jpg"/></td><td>Bill Venners is president of Artima, Inc., publisher of Artima Developer (www.artima.com). He is author of the book, <em>Inside the Java Virtual Machine</em>, a programmer-oriented survey of the Java platform's architecture and internals. His popular columns in JavaWorld magazine covered Java internals, object-oriented design, and Jini. Active in the Jini Community since its inception, Bill led the Jini Community's ServiceUI project, whose ServiceUI API became the de facto standard way to associate user interfaces to Jini services.  Bill is also the lead developer and designer of ScalaTest, an open source testing tool for Scala and Java developers, and coauthor with Martin Odersky and Lex Spoon of the book, <em>Programming in Scala</em>.</td></tr></table><p>
<div class="sp">This weblog entry is Copyright © 2009 Bill Venners. All rights reserved.</div>
</p></p></p></p></p></div>

<hr width="100%">
<table align="center" width="50%">
<tr>
<td>
<div class="horizontaltextadbox">
<div class="adheadline">Sponsored Links</div>
<div id="sponsoredlinks">
</div>
</div>
</td>
</tr>
</table>
<hr width="100%"/>
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script src="../_/https/pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
</script>
<br>
<br/>
<!-- SiteSearch Google -->
<form action="../_/https/www.google.com/custom/index.html" method="get">
<table bgcolor="#ffffff" border="0">
<tr><td align="left" height="32" nowrap="nowrap" valign="top">
<a href="../_/https/www.google.com/index.html">
<img alt="Google" border="0" src="../_/https/www.google.com/logos/Logo_25wht.gif"/></a>
</td>
<td nowrap="nowrap">
<input name="domains" type="hidden" value="Artima.com"/>
<input maxlength="255" name="q" size="31" type="text" value=""/>
<input name="sa" type="submit" value="Search"/>
</td></tr>
<tr>
<td> </td>
<td nowrap="nowrap">
<font color="#000000" size="-1">
<input name="sitesearch" type="radio" value=""/> Web
<input checked="checked" name="sitesearch" type="radio" value="Artima.com"/>Artima.com
</font>  
<input name="client" type="hidden" value="pub-3911176865765226"/>
<input name="forid" type="hidden" value="1"/>
<input name="ie" type="hidden" value="ISO-8859-1"/>
<input name="oe" type="hidden" value="ISO-8859-1"/>
<input name="cof" type="hidden" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;"/>
<input name="hl" type="hidden" value="en"/>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</br></center>
<br/>
<div class="sp">
<div style="text-align: center;">
<a href="../_/https/www.artima.com/copyright.html">Copyright</a> © 1996-2019 Artima, Inc. All Rights Reserved. - <a href="../_/https/www.artima.com/privacy.html">Privacy Policy</a> - <a href="../_/https/www.artima.com/termsofuse.html">Terms of Use</a>
</div>
</div>
<br/>
<script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = '../_/https/www.artima.com/zcr/index.html' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(3);
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('leftskyscraper');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>
</hr><a href="https://dafoster.net/projects/crystal-web-archiver/" id="cr-footer-banner" style="border-top: 2px #B40010 solid;background: #FFFAE1;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant: initial;font-weight: initial;text-transform: none;font-size: 14px;color: #6c757d;line-height: 2.0;cursor: pointer;display: flex;align-items: center;justify-content: center;gap: 4px;clear: both;" target="_blank"><img height="24" onerror="this.style['display'] = 'none';" src="../_/crystal/resources/appicon.png" width="24"/><span>This page was archived with Crystal</span><script>window.addEventListener('load', function() { const $1 = document.querySelector('#cr-footer-banner'); if (!$1) { return; } if (window !== window.top) { let $2 = false; if (window.name) { const $3 = window.parent.document.getElementsByName(window.name); if ($3.length === 1) { const $4 = $3[0]; if ($4.tagName === 'FRAME' && $4.parentElement.tagName === 'FRAMESET') { let $5 = $4; while (true) { if ($5.parentElement.tagName !== 'FRAMESET') { $2 = true; break; } if ($5.parentElement.attributes['rows'] !== undefined) { const $6 = $5.parentElement.children; if ($5 === $6[$6.length - 1]) { $5 = $5.parentElement; continue; } else { break; } } else if ($5.parentElement.attributes['cols'] !== undefined) { const $7 = Array.from($5.parentElement.children); const $8 = $7.indexOf($5); if ($8 === -1) { break; } const $9 = $5.parentElement.attributes['cols'].value.split(','); const $10 = $9.map((s) => parseInt(s.trim())); if ($9[$8].trim() === '*' || $10[$8] === Math.max.apply(null, $10)) { $5 = $5.parentElement; continue; } else { break; } } else { break; } } } } } if (!$2) { $1.style['display'] = 'none'; } } const $11 = $1.getBoundingClientRect(); const $12 = ($11.y < window.innerHeight - $11.height); if ($12) { $1.style['position'] = 'fixed'; $1.style['bottom'] = '0'; $1.style['left'] = '0'; $1.style['right'] = '0'; $1.style['z-index'] = '9999'; } const $13 = ( document.body.getBoundingClientRect().height < $11.height * 2 ); if ($13) { $1.style['display'] = 'none'; }
});</script></a></body>
</html>
