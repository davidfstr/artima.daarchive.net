
<!DOCTYPE html>

<html>
<head><meta content="noindex,nofollow" name="robots"/>
<title>Reflecting generics</title>
<meta charset="utf-8"/>
<meta content="Ian Robertson" name="author">
<link href="../_/https/www.artima.com/artima.css" rel="stylesheet" type="text/css"/>
<link href="../_/https/www.artima.com/favicon.ico" rel="shortcut icon"/>
</meta></head>
<body><table cellspacing="0" width="100%">
<tr>
<td align="left" valign="bottom">
<a href="../_/https/www.artima.com/index.html"><img alt="The Artima Developer Community" border="0" height="43" src="../_/https/www.artima.com/images/a7.gif" width="550"/></a>
</td>
</tr></table>
<table bgcolor="#333333" width="100%">
<tr>
<td align="center">
<div class="ml">
<a class="hl" href="../_/https/www.artima.com/articles/index.html">Articles</a> |
<a class="hl" href="../_/https/www.artima.com/news/index.html">News</a> |
<a class="hl" href="../index.html">Weblogs</a> |
<a class="hl" href="../_/https/www.artima.com/shop/catalog/index.html">Books</a> |
<a class="hl" href="../_/https/www.artima.com/forums/index.html">Forums</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#CCCCCC" width="100%">
<tr>
<td align="center">
<div class="sc">
<a href="../index.html">Artima Weblogs</a> | 

<a href="../index.html$/blogger=ianr.html">Ian Robertson's Weblog</a> | 

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=208860.html">Discuss</a> | 
<a href="mailto:?subject=Reflecting generics&amp;body= %0AArtima Weblogs %0AReflecting generics %0Aby Ian Robertson %0A%0Ahttps://www.artima.com/weblogs/viewpost.jsp?thread=208860">Email</a> | 
<a href="../viewpostP.html$/thread=208860.html">Print</a> | 
<a href="../bloggers.html">Bloggers</a> | 
Previous | 
<a class="sl" href="thread=218314.html" title="A case for member literals in Java">Next</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#EEEEEE" width="100%">
<tr>
<td align="center">
<div class="sc">
<span style="color: #555555;">Sponsored Link</span> <span style="color: #888888;">•</span>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a799ecf6.html" target="_top"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:9&amp;n=a0587811.html"/></a></noscript>
</div>
</td>
</tr>
</table>
<br/>
<div class="vegies">
<div class="tc">
<span class="sts">Code by Any Other Name</span><br>
<span class="ts">Reflecting generics</span><br/>
<span class="as">by Ian Robertson</span><br/>
<span class="pd">June 23, 2007</span><br/>
</br></div>
<blockquote>
<b>Summary</b><br/>
Type arguments to generic classes are not available for reflection at runtime - or are they?  The type arguments for statically declared types can be discovered at runtime.  A look at how to do this, and why you might want to.

</blockquote>
<hr align="left" width="90%"/>
<table align="right">
<tr>
<td>
<div class="adnotice">
Advertisement
</div>
<center>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
if (!document.phpAds_used) document.phpAds_used = ',';
phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
document.write ("&amp;what=zone:2");
document.write ("&amp;exclude=" + document.phpAds_used);
if (document.referrer)
document.write ("&amp;referer=" + escape(document.referrer));
document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a74ab060.html" target="_blank"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:2&amp;n=a74ab060.html"/></a></noscript>
</center>
</td>
</tr>
</table>
<p>
<p>
Probably the most common complaint about generics in Java is that
they are not reified - there is not a way to know at runtime that a
<code>List&lt;String&gt;</code> is any different from a <code>List&lt;Long&gt;</code>.
I've gotten so used to this that I was quite surprised to run across Neil Gafter's work on
<a href="../_/http/gafter.blogspot.com/2006/12/super-type-tokens.html">Super
Type Tokens</a>.  It turns out that while the JVM will not track the
actual type arguments for instances of a generic class, it does
track the actual type arguments for <i>subclasses</i> of generic
classes.  In other words, while a <code>new ArrayList&lt;String&gt;()</code>
is really just a <code>new ArrayList()</code> at runtime, if a class
extends <code>ArrayList&lt;String&gt;</code>, then the JVM knows that
<code>String</code> is the actual type argument for
<code>List</code>'s type parameter.

<p>Super type tokens are a nice trick to distinguish between types which have the same raw type, but different
type arguments.  What they don't easily provide, however, is an easy
means of discovering what the type argument for a generic type
parameter is.  I recently ran across a situation where I wanted to do exactly
that while trying to write an abstract base class to take some
of the work out of implementing Hibernate's <code><a href="../_/http/www.hibernate.org/hib_docs/v3/api/org/hibernate/usertype/UserType.html">UserType</a></code>
interface:

<p><code>
<font color="#7f0055">  <b>public interface </b></font><font color="#000000">UserType </font><font color="#000000">{</font><br>
<font color="#ffffff">    </font><font color="#3f5fbf">/**</font><br/>
<font color="#ffffff">     </font><font color="#3f5fbf">* The class returned by </font><font color="#7f7f9f">&lt;tt&gt;</font><font color="#3f5fbf">nullSafeGet()</font><font color="#7f7f9f">&lt;/tt&gt;</font><font color="#3f5fbf">.</font><br/>
<font color="#ffffff">     </font><font color="#3f5fbf">*/</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">Class returnedClass</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#3f5fbf">/**</font><br/>
<font color="#ffffff">     </font><font color="#3f5fbf">* Retrieve an instance of the mapped class from a JDBC resultset.</font><br/>
<font color="#ffffff">     </font><font color="#3f5fbf">*/</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">Object nullSafeGet</font><font color="#000000">(</font><font color="#000000">ResultSet rs, String</font><font color="#000000">[] </font><font color="#000000">names, Object owner</font><font color="#000000">) </font><font color="#7f0055"><b>throws </b></font><font color="#000000">SQLException;</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#3f5fbf">/**</font><br/>
<font color="#ffffff">     </font><font color="#3f5fbf">* Write an instance of the mapped class to a prepared statement.</font><br/>
<font color="#ffffff">     </font><font color="#3f5fbf">*/</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#7f0055"><b>void </b></font><font color="#000000">nullSafeSet</font><font color="#000000">(</font><font color="#000000">PreparedStatement st, Object value, </font><font color="#7f0055"><b>int </b></font><font color="#000000">index</font><font color="#000000">) </font><font color="#7f0055"><b>throws </b></font><font color="#000000">SQLException;</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#000000">  }</font></br></code>
</p>
<code>UserType</code> is used to provide custom mappings between database values
and Java objects.  For example, one might need a <code>UserType</code> implementation to map a textual
representation of dates (stored as <code>VARCHAR</code>s) to the <code>Date</code> class.

Because Hibernate needs
to support Java 1.4, the <code>UserType</code> interface is not itself generic, but it makes plenty of sense
for a base class which implements it to take advantage of generics.  In a reified world I might have something like:

<p><code>
<font color="#7f0055">  <b>public abstract class </b></font><font color="#000000">AbstractUserType&lt;T&gt; </font><font color="#7f0055"><b>implements </b></font><font color="#000000">UserType </font><font color="#000000">{</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">Class returnedClass</font><font color="#000000">() {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return </b></font><font color="#000000">T.</font><font color="#7f0055"><b>class</b></font><font color="#000000">; </font><font color="#3f7f5f">//not remotely legal in Java 5 or 6.</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>abstract public </b></font><font color="#000000">T nullSafeGet</font><font color="#000000">(</font><font color="#000000">ResultSet rs, String</font><font color="#000000">[] </font><font color="#000000">names, Object owner</font><font color="#000000">) </font><font color="#7f0055"><b>throws </b></font><font color="#000000">SQLException;</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>abstract protected </b></font><font color="#7f0055"><b>void </b></font><font color="#000000">set</font><font color="#000000">(</font><font color="#000000">PreparedStatement st, T value, </font><font color="#7f0055"><b>int </b></font><font color="#000000">index</font><font color="#000000">) </font><font color="#7f0055"><b>throws </b></font><font color="#000000">SQLException;</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#7f0055"><b>void </b></font><font color="#000000">nullSafeSet</font><font color="#000000">(</font><font color="#000000">PreparedStatement st, Object value, </font><font color="#7f0055"><b>int </b></font><font color="#000000">index</font><font color="#000000">) </font><font color="#7f0055"><b>throws </b></font><font color="#000000">SQLException </font><font color="#000000">{</font><br/>
<font color="#ffffff">      </font><font color="#000000">set</font><font color="#000000">(</font><font color="#000000">st, </font><font color="#000000">(</font><font color="#000000">T</font><font color="#000000">) </font><font color="#000000">value, index</font><font color="#000000">)</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff"></font><br/>
<font color="#000000">  }</font></code>
</p>

Unfortunately, because of type erasure, the "obvious" implementation of
<code>returnedClass()</code> doesn't work.  Indeed, an often used pattern in generic
programming is to require the type argument class as a method parameter:

<p><code>
<font color="#7f0055">  <b>public abstract class </b></font><font color="#000000">AbstractUserType&lt;T&gt; </font><font color="#7f0055"><b>implements </b></font><font color="#000000">UserType </font><font color="#000000">{</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>private </b></font><font color="#000000">Class&lt;T&gt; returnedClass;</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>protected </b></font><font color="#000000">AbstractUserType</font><font color="#000000">(</font><font color="#000000">Class&lt;T&gt; returnedClass</font><font color="#000000">) {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>this</b></font><font color="#000000">.returnedClass = returnedClass;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">Class returnedClass</font><font color="#000000">() {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return </b></font><font color="#000000">returnedClass;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#000000">  }</font></code>
</p>

While this works, it does so at the cost of forcing clients to repeat themselves:
<p><code>
<font color="#7f0055">  <b>public class </b></font><font color="#000000">DateType </font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>extends </b></font><font color="#000000">AbstractUserType&lt;Date&gt; </font><font color="#000000">{ </font><font color="#3f7f5f">// One for the money</font><br/>
<font color="#ffffff">  </font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">DateType</font><font color="#000000">() {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>super</b></font><font color="#000000">(</font><font color="#000000">Date.</font><font color="#7f0055"><b>class</b></font><font color="#000000">)</font><font color="#000000">; </font><font color="#3f7f5f">// Two for the show</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#000000">  }</font></code>
</p>

It turns out, however, that even though we cannot access the type of <code>T</code> directly, we can
get at our current class, and use the new interfaces extending <code><a href="../_/http/java.sun.com/j2se/1.5.0/docs/api/java/lang/reflect/Type.html">java.lang.reflect.Type</a></code>
(introduced in Java 5) to get at what we need.  A new method on
<code>Class</code> was introduced, <code><a href="../_/http/java.sun.com/j2se/1.5.0/docs/api/java/lang/Class.html#getGenericSuperclass()">getGenericSuperclass()</a></code>.
If the class's parent is a generic class, then this will return a
<code><a href="../_/http/java.sun.com/j2se/1.5.0/docs/api/java/lang/reflect/ParameterizedType.html">ParameterizedType</a></code>.
The <code>getActualTypeArguments()</code> method on
<code>ParameterizedType</code> in turn provides an array of the actual
type arguments that were used in extending the parent class.

<p>At first glance, then, it seems that the following ought to do the trick:

<p>
<code>
<font color="#7f0055">  <b>public abstract class </b></font><font color="#000000">AbstractUserType&lt;T&gt; </font><font color="#7f0055"><b>implements </b></font><font color="#000000">UserType </font><font color="#000000">{</font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">Class returnedClass </font><font color="#000000">{</font><br/>
<font color="#ffffff">      </font><font color="#000000">ParameterizedType parameterizedType =</font><br/>
<font color="#ffffff">        </font><font color="#000000">(</font><font color="#000000">ParameterizedType</font><font color="#000000">) </font><font color="#000000">getClass</font><font color="#000000">()</font><font color="#000000">.getGenericSuperClass</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">     </font><font color="#7f0055"><b>return </b></font><font color="#000000">(</font><font color="#000000">Class</font><font color="#000000">) </font><font color="#000000">parameterizedtype.getActualTypeArguments</font><font color="#000000">()[</font><font color="#990000">0</font><font color="#000000">]</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#000000">  }</font></code>
</p>
<p>
 Indeed, for a class that directly extends <code>AbstractUserType</code> (and
provides a non-array class for the type parameter), this works
well.   However, in general, several problems can occur:

<ul>
<li>For a class extending <code>AbstractUserType&lt;int[]&gt;</code>, the result of the
      call to <code>getActualTypeArguments()[0]</code> will be a
      <code>GenericArrayType</code>, even though one might expect it
      to be of type <code>Class</code>.</li>
<li>If <code>Child</code> extends <code>AbstractUserType</code>, and <code>Grandchild</code>
    extends <code>Child</code>, then the type returned by
    <code>Grandchild.class.getGenericSuperClass()</code> will be referencing <code>Child</code>, not
    <code>AbstractUserType</code>, and hence any actual type arguments would be those provided by
    <code>Grandchild</code>.  Even worse, if <code>Child</code> is not itself a generic
    class, then <code>Grandchild.class.getGenericSuperClass()</code> will
    return <code>Child.class</code>, which is of type <code>Class</code>,
    not <code>ParameterizedType</code>.
  </li>
<li>Given class declarations:
<p><code>
<font color="#ffffff">  </font><font color="#7f0055"><b>public class </b></font><font color="#000000">Child&lt;S&gt; </font><font color="#7f0055"><b>extends </b></font><font color="#000000">AbstractUserType&lt;T&gt;</font><font color="#000000">{</font><font color="#000000">...</font><font color="#000000">}</font><br/>
<font color="#ffffff"></font><br/>
<font color="#ffffff">  </font><font color="#7f0055"><b>public class </b></font><font color="#000000">GrandChild </font><font color="#7f0055"><b>extends </b></font><font color="#000000">Child&lt;Long&gt;</font><font color="#000000">{</font><font color="#000000">...</font><font color="#000000">}</font></code>
</p>
 then
    <code>Child.class.getGenericSuperClass()</code> will return a
    <code>ParameterizedType</code> whose actual type argument is a
    <code><a href="../_/http/java.sun.com/j2se/1.5.0/docs/api/java/lang/reflect/TypeVariable.html">TypeVariable</a></code>
    representing the type parameter <code>S</code>.  This type variable
    (or one which is <code>.equals()</code> to it) will also be the sole
    element of the array returned by
    <code>Grandchild.class.getTypeParameters()</code>.  To get the "actual actual"
    type argument to <code>AbstractUserType</code>, it is necessary to link these two together.</li>
</ul>

That said, it is possible to accomplish what we want.  The first step is to
provide a method which might have been polite for Sun to include in the <code>Type</code>
interface itself (as it stands, <code>Type</code> is strictly a marker interface):

<p>
<code>
<font color="#ffffff">  </font><font color="#3f5fbf">/**</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* Get the underlying class for a type, or null if the type is a variable type.</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* </font><font color="#7f9fbf">@param </font><font color="#3f5fbf">type the type</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* </font><font color="#7f9fbf">@return </font><font color="#3f5fbf">the underlying class</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">*/</font><br/>
<font color="#ffffff">  </font><font color="#7f0055"><b>public static </b></font><font color="#000000">Class&lt;?&gt; getClass</font><font color="#000000">(</font><font color="#000000">Type type</font><font color="#000000">) {</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>if </b></font><font color="#000000">(</font><font color="#000000">type </font><font color="#7f0055"><b>instanceof </b></font><font color="#000000">Class</font><font color="#000000">) {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return </b></font><font color="#000000">(</font><font color="#000000">Class</font><font color="#000000">) </font><font color="#000000">type;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>else if </b></font><font color="#000000">(</font><font color="#000000">type </font><font color="#7f0055"><b>instanceof </b></font><font color="#000000">ParameterizedType</font><font color="#000000">) {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return </b></font><font color="#000000">getClass</font><font color="#000000">(((</font><font color="#000000">ParameterizedType</font><font color="#000000">) </font><font color="#000000">type</font><font color="#000000">)</font><font color="#000000">.getRawType</font><font color="#000000">())</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>else if </b></font><font color="#000000">(</font><font color="#000000">type </font><font color="#7f0055"><b>instanceof </b></font><font color="#000000">GenericArrayType</font><font color="#000000">) {</font><br/>
<font color="#ffffff">      </font><font color="#000000">Type componentType = </font><font color="#000000">((</font><font color="#000000">GenericArrayType</font><font color="#000000">) </font><font color="#000000">type</font><font color="#000000">)</font><font color="#000000">.getGenericComponentType</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">      </font><font color="#000000">Class&lt;?&gt; componentClass = getClass</font><font color="#000000">(</font><font color="#000000">componentType</font><font color="#000000">)</font><font color="#000000">;</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>if </b></font><font color="#000000">(</font><font color="#000000">componentClass != </font><font color="#7f0055"><b>null </b></font><font color="#000000">) {</font><br/>
<font color="#ffffff">        </font><font color="#7f0055"><b>return </b></font><font color="#000000">Array.newInstance</font><font color="#000000">(</font><font color="#000000">componentClass, </font><font color="#990000">0</font><font color="#000000">)</font><font color="#000000">.getClass</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">      </font><font color="#000000">}</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>else </b></font><font color="#000000">{</font><br/>
<font color="#ffffff">        </font><font color="#7f0055"><b>return null</b></font><font color="#000000">;</font><br/>
<font color="#ffffff">      </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>else </b></font><font color="#000000">{</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return null</b></font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">  </font><font color="#000000">}</font></code>
</p>

Note that we basically "give up" if we hit an unbound type variable; since the goal here is to
find a class, we might as well.

<p>The next step is a bit more involved.  We need to look at the
actual type arguments provided to the super class of the class in question.  If that super class is
the base class we are interested in, then we are done.  Otherwise, we need to repeat this process.
However, the actual type arguments we have just looked at may themselves be used as actual type
arguments to the next class up the inheritance hierarchy.  Unfortunately, Java will not track this
for us; we'll need to do it ourselves.

<p>
<code>
<font color="#ffffff">  </font><font color="#3f5fbf">/**</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* Get the actual type arguments a child class has used to extend a generic base class.</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">*</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* </font><font color="#7f9fbf">@param </font><font color="#3f5fbf">baseClass the base class</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* </font><font color="#7f9fbf">@param </font><font color="#3f5fbf">childClass the child class</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">* </font><font color="#7f9fbf">@return </font><font color="#3f5fbf">a list of the raw classes for the actual type arguments.</font><br/>
<font color="#ffffff">   </font><font color="#3f5fbf">*/</font><br/>
<font color="#ffffff">  </font><font color="#7f0055"><b>public static </b></font><font color="#000000">&lt;T&gt; List&lt;Class&lt;?&gt;&gt; getTypeArguments</font><font color="#000000">(</font><br/>
<font color="#ffffff">    </font><font color="#000000">Class&lt;T&gt; baseClass, Class&lt;? </font><font color="#7f0055"><b>extends </b></font><font color="#000000">T&gt; childClass</font><font color="#000000">) {</font><br/>
<font color="#ffffff">    </font><font color="#000000">Map&lt;Type, Type&gt; resolvedTypes = </font><font color="#7f0055"><b>new </b></font><font color="#000000">HashMap&lt;Type, Type&gt;</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">Type type = childClass;</font><br/>
<font color="#ffffff">    </font><font color="#3f7f5f">// start walking up the inheritance hierarchy until we hit baseClass</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>while </b></font><font color="#000000">(</font><font color="#000000">! getClass</font><font color="#000000">(</font><font color="#000000">type</font><font color="#000000">)</font><font color="#000000">.equals</font><font color="#000000">(</font><font color="#000000">baseClass</font><font color="#000000">)) {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>if </b></font><font color="#000000">(</font><font color="#000000">type </font><font color="#7f0055"><b>instanceof </b></font><font color="#000000">Class</font><font color="#000000">) {</font><br/>
<font color="#ffffff">        </font><font color="#3f7f5f">// there is no useful information for us in raw types, so just keep going.</font><br/>
<font color="#ffffff">        </font><font color="#000000">type = </font><font color="#000000">((</font><font color="#000000">Class</font><font color="#000000">) </font><font color="#000000">type</font><font color="#000000">)</font><font color="#000000">.getGenericSuperclass</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">      </font><font color="#000000">}</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>else </b></font><font color="#000000">{</font><br/>
<font color="#ffffff">        </font><font color="#000000">ParameterizedType parameterizedType = </font><font color="#000000">(</font><font color="#000000">ParameterizedType</font><font color="#000000">) </font><font color="#000000">type;</font><br/>
<font color="#ffffff">        </font><font color="#000000">Class&lt;?&gt; rawType = </font><font color="#000000">(</font><font color="#000000">Class</font><font color="#000000">) </font><font color="#000000">parameterizedType.getRawType</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">  </font><br/>
<font color="#ffffff">        </font><font color="#000000">Type</font><font color="#000000">[] </font><font color="#000000">actualTypeArguments = parameterizedType.getActualTypeArguments</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">        </font><font color="#000000">TypeVariable&lt;?&gt;</font><font color="#000000">[] </font><font color="#000000">typeParameters = rawType.getTypeParameters</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">        </font><font color="#7f0055"><b>for </b></font><font color="#000000">(</font><font color="#7f0055"><b>int </b></font><font color="#000000">i = </font><font color="#990000">0</font><font color="#000000">; i &lt; actualTypeArguments.length; i++</font><font color="#000000">) {</font><br/>
<font color="#ffffff">          </font><font color="#000000">resolvedTypes.put</font><font color="#000000">(</font><font color="#000000">typeParameters</font><font color="#000000">[</font><font color="#000000">i</font><font color="#000000">]</font><font color="#000000">, actualTypeArguments</font><font color="#000000">[</font><font color="#000000">i</font><font color="#000000">])</font><font color="#000000">;</font><br/>
<font color="#ffffff">        </font><font color="#000000">}</font><br/>
<font color="#ffffff">  </font><br/>
<font color="#ffffff">        </font><font color="#7f0055"><b>if </b></font><font color="#000000">(</font><font color="#000000">!rawType.equals</font><font color="#000000">(</font><font color="#000000">baseClass</font><font color="#000000">)) {</font><br/>
<font color="#ffffff">          </font><font color="#000000">type = rawType.getGenericSuperclass</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">        </font><font color="#000000">}</font><br/>
<font color="#ffffff">      </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">  </font><br/>
<font color="#ffffff">    </font><font color="#3f7f5f">// finally, for each actual type argument provided to baseClass, determine (if possible)</font><br/>
<font color="#ffffff">    </font><font color="#3f7f5f">// the raw class for that type argument.</font><br/>
<font color="#ffffff">    </font><font color="#000000">Type</font><font color="#000000">[] </font><font color="#000000">actualTypeArguments;</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>if </b></font><font color="#000000">(</font><font color="#000000">type </font><font color="#7f0055"><b>instanceof </b></font><font color="#000000">Class</font><font color="#000000">) {</font><br/>
<font color="#ffffff">      </font><font color="#000000">actualTypeArguments = </font><font color="#000000">((</font><font color="#000000">Class</font><font color="#000000">) </font><font color="#000000">type</font><font color="#000000">)</font><font color="#000000">.getTypeParameters</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>else </b></font><font color="#000000">{</font><br/>
<font color="#ffffff">      </font><font color="#000000">actualTypeArguments = </font><font color="#000000">((</font><font color="#000000">ParameterizedType</font><font color="#000000">) </font><font color="#000000">type</font><font color="#000000">)</font><font color="#000000">.getActualTypeArguments</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#000000">List&lt;Class&lt;?&gt;&gt; typeArgumentsAsClasses = </font><font color="#7f0055"><b>new </b></font><font color="#000000">ArrayList&lt;Class&lt;?&gt;&gt;</font><font color="#000000">()</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#3f7f5f">// resolve types by chasing down type variables.</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>for </b></font><font color="#000000">(</font><font color="#000000">Type baseType: actualTypeArguments</font><font color="#000000">) {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>while </b></font><font color="#000000">(</font><font color="#000000">resolvedTypes.containsKey</font><font color="#000000">(</font><font color="#000000">baseType</font><font color="#000000">)) {</font><br/>
<font color="#ffffff">        </font><font color="#000000">baseType = resolvedTypes.get</font><font color="#000000">(</font><font color="#000000">baseType</font><font color="#000000">)</font><font color="#000000">;</font><br/>
<font color="#ffffff">      </font><font color="#000000">}</font><br/>
<font color="#ffffff">      </font><font color="#000000">typeArgumentsAsClasses.add</font><font color="#000000">(</font><font color="#000000">getClass</font><font color="#000000">(</font><font color="#000000">baseType</font><font color="#000000">))</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>return </b></font><font color="#000000">typeArgumentsAsClasses;</font><br/>
<font color="#ffffff">  </font><font color="#000000">}</font></code>
</p>

Finally, we can accomplish our original goal:

<p>
<code>
<font color="#ffffff">  </font><font color="#7f0055"><b>public abstract class </b></font><font color="#000000">AbstractUserType&lt;T&gt; </font><font color="#7f0055"><b>implements </b></font><font color="#000000">UserType </font><font color="#000000">{</font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#ffffff">    </font><font color="#7f0055"><b>public </b></font><font color="#000000">Class returnedClass </font><font color="#000000">{</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return </b></font><font color="#000000">getTypeArguments(AbstractUserType.class, getClass()).get(0);</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#ffffff">    </font><font color="#000000">...</font><br/>
<font color="#ffffff">  </font><font color="#000000">}</font></code>
</p>
<p>
While in this case, we are returning raw classes, other use cases might want to see the extended
type information for the actual type arguments.
Unfortunately, we cannot do this in the case where an actual type argument is a type variable.
For example, if the actual type argument for type parameter <code>T</code> is <code>Long</code>,
and we are trying to resolve <code>List&lt;T&gt;</code>, we cannot do so without creating a new
<code>ParameterizedType</code> instance for the type <code>Long&lt;T&gt;</code>.
Since the <code>ParameterizedType</code> implementation
provided by Sun is non-instantiable by mere mortals, this would require  (re)implementing
<code>ParameterizedType</code>.  However, since the algorithm for the <code>hashCode</code> method
for <code>ParameterizedType</code> is not documented, this cannot be safely accomplished.
In particular, it would not be possible to create one of Gafter's Super Type Tokens to represent
the actual type argument.

<p>That limitation noted, this can still be useful, and not just for the motivating example above.
For example, one could extend <code>ArrayList</code> to get the dynamic return type of
<code>toArray()</code> right without help:
<p><code>
<font color="#7f0055">  <b>public abstract class </b></font><font color="#000000">TypeAwareArrayList&lt;T&gt; </font><font color="#7f0055"><b>extends </b></font><font color="#000000">ArrayList&lt;T&gt; </font><font color="#000000">{</font><br/>
<font color="#ffffff">    </font><font color="#646464">@Override </font><font color="#7f0055"><b>public </b></font><font color="#000000">T</font><font color="#000000">[] </font><font color="#000000">toArray</font><font color="#000000">() {</font><br/>
<font color="#ffffff">      </font><font color="#7f0055"><b>return </b></font><font color="#000000">toArray</font><font color="#000000">(</font><br/>
<font color="#ffffff">        </font><font color="#000000">(</font><font color="#000000">T</font><font color="#000000">[]) </font><font color="#000000">Array.newInstance</font><font color="#000000">(</font><br/>
<font color="#ffffff">          </font><font color="#000000">ReflectionUtils.getTypeArguments</font><font color="#000000">(</font><font color="#000000">TypeAwareArrayList.class, getClass</font><font color="#000000">())</font><font color="#000000">.get</font><font color="#000000">(</font><font color="#990000">0</font><font color="#000000">)</font><font color="#000000">,</font><br/>
<font color="#ffffff">        </font><font color="#000000">size</font><font color="#000000">()))</font><font color="#000000">;</font><br/>
<font color="#ffffff">    </font><font color="#000000">}</font><br/>
<font color="#000000">  }</font></code>
</p>
<p>
Note that <code>TypeAwareArrayList</code> is declared <code>abstract</code>.
This forces client code to extend it, if only trivially, so that the type information is available:

<p><code>
<font color="#ffffff">  </font><font color="#000000">TypeAwareArrayList&lt;String&gt; stringList</font><br/>
<font color="#ffffff">    </font><font color="#000000">= </font><font color="#7f0055"><b>new </b></font><font color="#000000">TypeAwareArrayList&lt;String&gt;</font><font color="#000000">(){}</font><font color="#000000">; </font><font color="#3f7f5f">// notice the trivial anonymous inner class</font><br/>
<font color="#ffffff">  </font><font color="#000000">...</font><br/>
<font color="#ffffff">  </font><font color="#000000">String</font><font color="#000000">[] </font><font color="#000000">stringArray = stringList.toArray</font><font color="#000000">()</font><font color="#000000">;</font></code>
</p>
<p>
While the discussion above has been focused on subclasses, similar generics-aware reflection
can be done for methods and fields.  As with classes, the main thing to remember is that while the
dynamic runtime typing of objects is ignorant of generic typing, the type arguments to statically
declared types can be discovered through reflection.  Hopefully, Java 7 can "erase erasure", and get
rid of this frustrating distinction.

<img align="top" height="15" src="../_/https/www.artima.com/images/ik.gif" width="15"/>
<h1>Talk Back!</h1>
<p>
Have an opinion?


Readers have already posted

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=208860.html">26

comments</a>
about this weblog entry. Why not

<a href="../_/https/www.artima.com/forums/post.html$/forum=106&amp;thread=208860&amp;reply=true.html">add yours</a>?


<h1>RSS Feed</h1>
<p>
If you'd like to be notified whenever Ian Robertson adds a new entry to <a href="../index.html$/blogger=ianr.html">his weblog</a>, subscribe to his <a href="../feeds/bloggers/ianr.rss">RSS feed</a>.

<center>
<div class="sociallinks">
<a href="../_/http/digg.com/submit$/phase=2&amp;url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D208860&amp;title=Reflecting+generics&amp;bodytext=Type+arguments+to+generic+classes+are+not+available+for+reflection+at+runtime+-+or+are+they%3F++The+type+arguments+for+statically+declared+types+can+be+discovered+at+runtime.++A+look+at+how+to+do+this%2C+and+why+you+might+want+to.&amp;topic=programming">
<img alt="Digg" border="0" height="14" hspace="8" src="../_/https/www.artima.com/images/digg.gif" width="16">Digg
  </img></a>
  |
  <a href="../_/http/del.icio.us/post$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D208860&amp;title=Reflecting+generics">
<img alt="del.icio.us" border="0" height="16" hspace="8" src="../_/https/www.artima.com/images/delicious.gif" vspace="1" width="16">del.icio.us
  </img></a>
  |
  <a href="../_/http/programming.reddit.com/submit$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D208860&amp;title=Reflecting+generics">
<img alt="Reddit" border="0" height="18" hspace="8" src="../_/https/www.artima.com/images/reddit.gif" width="18">Reddit
  </img></a>
</div>
</center>
<h1>About the Blogger</h1>
<p>
<table><tr valign="bottom"><td><img align="right" src="../_/https/www.artima.com/images/ianRobertson.jpg"/></td><td>Ian Robertson is an application architect at Verisk Health. He is interested in finding concise means of expression in Java without sacrificing type safety. He contributes to various open source projects, including <a href="../_/http/www.jamon.org/index.html">jamon</a> and <a href="../_/http/www.pojomatic.org/index.html">pojomatic</a>.</td></tr></table><p>
<div class="sp">This weblog entry is Copyright © 2007 Ian Robertson. All rights reserved.</div>
</p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>

<hr width="100%">
<table align="center" width="50%">
<tr>
<td>
<div class="horizontaltextadbox">
<div class="adheadline">Sponsored Links</div>
<div id="sponsoredlinks">
</div>
</div>
</td>
</tr>
</table>
<hr width="100%"/>
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script src="../_/https/pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
</script>
<br/>
<br/>
<!-- SiteSearch Google -->
<form action="../_/https/www.google.com/custom/index.html" method="get">
<table bgcolor="#ffffff" border="0">
<tr><td align="left" height="32" nowrap="nowrap" valign="top">
<a href="../_/https/www.google.com/index.html">
<img alt="Google" border="0" src="../_/https/www.google.com/logos/Logo_25wht.gif"/></a>
</td>
<td nowrap="nowrap">
<input name="domains" type="hidden" value="Artima.com"/>
<input maxlength="255" name="q" size="31" type="text" value=""/>
<input name="sa" type="submit" value="Search"/>
</td></tr>
<tr>
<td> </td>
<td nowrap="nowrap">
<font color="#000000" size="-1">
<input name="sitesearch" type="radio" value=""/> Web
<input checked="checked" name="sitesearch" type="radio" value="Artima.com"/>Artima.com
</font>  
<input name="client" type="hidden" value="pub-3911176865765226"/>
<input name="forid" type="hidden" value="1"/>
<input name="ie" type="hidden" value="ISO-8859-1"/>
<input name="oe" type="hidden" value="ISO-8859-1"/>
<input name="cof" type="hidden" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;"/>
<input name="hl" type="hidden" value="en"/>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</center>
<br/>
<div class="sp">
<div style="text-align: center;">
<a href="../_/https/www.artima.com/copyright.html">Copyright</a> © 1996-2019 Artima, Inc. All Rights Reserved. - <a href="../_/https/www.artima.com/privacy.html">Privacy Policy</a> - <a href="../_/https/www.artima.com/termsofuse.html">Terms of Use</a>
</div>
</div>
<br/>
<script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = '../_/https/www.artima.com/zcr/index.html' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(3);
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('leftskyscraper');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>
</hr><a href="https://dafoster.net/projects/crystal-web-archiver/" id="cr-footer-banner" style="border-top: 2px #B40010 solid;background: #FFFAE1;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant: initial;font-weight: initial;text-transform: none;font-size: 14px;color: #6c757d;line-height: 2.0;cursor: pointer;display: flex;align-items: center;justify-content: center;gap: 4px;clear: both;" target="_blank"><img height="24" onerror="this.style['display'] = 'none';" src="../_/crystal/resources/appicon.png" width="24"/><span>This page was archived with Crystal</span><script>window.addEventListener('load', function() { const $1 = document.querySelector('#cr-footer-banner'); if (!$1) { return; } if (window !== window.top) { let $2 = false; if (window.name) { const $3 = window.parent.document.getElementsByName(window.name); if ($3.length === 1) { const $4 = $3[0]; if ($4.tagName === 'FRAME' && $4.parentElement.tagName === 'FRAMESET') { let $5 = $4; while (true) { if ($5.parentElement.tagName !== 'FRAMESET') { $2 = true; break; } if ($5.parentElement.attributes['rows'] !== undefined) { const $6 = $5.parentElement.children; if ($5 === $6[$6.length - 1]) { $5 = $5.parentElement; continue; } else { break; } } else if ($5.parentElement.attributes['cols'] !== undefined) { const $7 = Array.from($5.parentElement.children); const $8 = $7.indexOf($5); if ($8 === -1) { break; } const $9 = $5.parentElement.attributes['cols'].value.split(','); const $10 = $9.map((s) => parseInt(s.trim())); if ($9[$8].trim() === '*' || $10[$8] === Math.max.apply(null, $10)) { $5 = $5.parentElement; continue; } else { break; } } else { break; } } } } } if (!$2) { $1.style['display'] = 'none'; } } const $11 = $1.getBoundingClientRect(); const $12 = ($11.y < window.innerHeight - $11.height); if ($12) { $1.style['position'] = 'fixed'; $1.style['bottom'] = '0'; $1.style['left'] = '0'; $1.style['right'] = '0'; $1.style['z-index'] = '9999'; } const $13 = ( document.body.getBoundingClientRect().height < $11.height * 2 ); if ($13) { $1.style['display'] = 'none'; }
});</script></a></body>
</html>
