
<!DOCTYPE html>

<html>
<head><meta content="noindex,nofollow" name="robots"/>
<title>Bolt-Ins for Contract and Extension Classes</title>
<meta charset="utf-8"/>
<meta content="Christopher Diggins" name="author">
<link href="../_/https/www.artima.com/artima.css" rel="stylesheet" type="text/css"/>
<link href="../_/https/www.artima.com/favicon.ico" rel="shortcut icon"/>
</meta></head>
<body><table cellspacing="0" width="100%">
<tr>
<td align="left" valign="bottom">
<a href="../_/https/www.artima.com/index.html"><img alt="The Artima Developer Community" border="0" height="43" src="../_/https/www.artima.com/images/a7.gif" width="550"/></a>
</td>
</tr></table>
<table bgcolor="#333333" width="100%">
<tr>
<td align="center">
<div class="ml">
<a class="hl" href="../_/https/www.artima.com/articles/index.html">Articles</a> |
<a class="hl" href="../_/https/www.artima.com/news/index.html">News</a> |
<a class="hl" href="../index.html">Weblogs</a> |
<a class="hl" href="../_/https/www.artima.com/shop/catalog/index.html">Books</a> |
<a class="hl" href="../_/https/www.artima.com/forums/index.html">Forums</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#CCCCCC" width="100%">
<tr>
<td align="center">
<div class="sc">
<a href="../index.html">Artima Weblogs</a> | 

<a href="../index.html$/blogger=cdiggins.html">Christopher Diggins' Weblog</a> | 

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=106760.html">Discuss</a> | 
<a href="mailto:?subject=Bolt-Ins for Contract and Extension Classes&amp;body= %0AArtima Weblogs %0ABolt-Ins for Contract and Extension Classes %0Aby Christopher Diggins %0A%0Ahttps://www.artima.com/weblogs/viewpost.jsp?thread=106760">Email</a> | 
<a href="../viewpostP.html$/thread=106760.html">Print</a> | 
<a href="../bloggers.html">Bloggers</a> | 
<a class="sl" href="thread=106524.html" title="Two Stage Construction in C++ versus Initializing Constructors">Previous</a> | 
<a class="sl" href="thread=107338.html" title="Coupling is not neccessarily a bad thing!">Next</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#EEEEEE" width="100%">
<tr>
<td align="center">
<div class="sc">
<span style="color: #555555;">Sponsored Link</span> <span style="color: #888888;">•</span>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a799ecf6.html" target="_top"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:9&amp;n=a0587811.html"/></a></noscript>
</div>
</td>
</tr>
</table>
<br/>
<div class="vegies">
<div class="tc">
<span class="sts">Heron-Centric: Ruminations of a Language Designer</span><br>
<span class="ts">Bolt-Ins for Contract and Extension Classes</span><br/>
<span class="as">by Christopher Diggins</span><br/>
<span class="pd">April 27, 2005</span><br/>
</br></div>
<blockquote>
<b>Summary</b><br/>
At Matthew Wilson's behest, I have attempted to further explain my rationale behind separate extension classes, and contract verification classes. It turns out they fit very nicely in a design pattern which Matthew refers to as a bolt-in.

</blockquote>
<hr align="left" width="90%"/>
<table align="right">
<tr>
<td>
<div class="adnotice">
Advertisement
</div>
<center>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
if (!document.phpAds_used) document.phpAds_used = ',';
phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
document.write ("&amp;what=zone:2");
document.write ("&amp;exclude=" + document.phpAds_used);
if (document.referrer)
document.write ("&amp;referer=" + escape(document.referrer));
document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a74ab060.html" target="_blank"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:2&amp;n=a74ab060.html"/></a></noscript>
</center>
</td>
</tr>
</table>
<p>
<h2>Bolt-Ins</h2>

A bolt-in is a sub-case of template parameter inheritance.
Matthew Wilson defines a bolt-in (a term he attributes to his colleagues
Leigh and Scott Perry) in his book <i>Imperfect C++</i> as follows:

<blockquote>
Bolt-ins are template classes with the following characteristics:
<ul>
<li>They derive, usually publicly, from their primary parameterizing type.</li>
<li>They accomodate the polymorphic nature of their primary parameterizing types.
Usually they also adhere to the nature, but this is not always the case, and they may define virtual
methods of their own, in addition to overriding those defined
by the primary parameterizing type.</li>
<li>They may increase the footprint of the primary parameterizing type by the definitiion of member variables,
virtual functions, and additional inheritance from nonempty types.</li>
</ul>
<p>
- <i>Imperfect C++, page 375, by Matthew Wilson, published by Addison-Wesley, 2005</i>
</p></blockquote>

In all frankness I consider that to be a somewhat fluffy defintion, and I would have stated it more concisely as follows:

<blockquote>
Bolt-ins are template classes which inherit from their primary parameterizing type, while accomodating its polymorphic nature.
</blockquote>

The other parts of the definition are superflous, and do not add to the definition. They appear to be solely intended to
distinguish bolt-ins from veneers.
Matthew goes on to disintiguish a bolt-in primarily by its role:

<blockquote>
... bolt-ins are concerned with significantly changing or completing
the behavioural nature of (often partially defined) types. [...] The primary purpose of a bolt-in is to
add or enhance functionality.
<p>
- <i>Imperfect C++, page 375, by Matthew Wilson, published by Addison-Wesley, 2005</i>
</p></blockquote>

Unfortunately I find it difficult to identify specifically when I am using a bolt-in and when I am using plain old template parameter
inheritance. However I will use the term bolt-in for the time being. I would however like to encourage Matthew to further refine the definitions
of bolt-ins, veneers and attempt to formalize the other forms of template parameter inheritance patterns. On that note, Joel de Guzman suggested the term
<a href="../_/http/www.boost.org/libs/spirit/phoenix/doc/actors_revisited.html">Parametric Base Class Pattern</a> (PBCP) for all the forms
of template parameter inheritance.

<h2>Separation of Concerns</h2>

The software engineering notion of "separation of concerns" refers to the fact that within a well-engineered
piece of software, we should find code which is responsible for a specific concern located within a single module.
<p>
Following the principle of separation of concerns has the benefit of reduction of code coupling, and improvement of code cohesion.
These are both well-known good software engineering practices. The advantages are that following these principles more naturally leads
to more maintainable and reusable code.
<p>
Bolt-ins can be used to enforce separation of concerns, and to reduce code coupling.

<h2>Programming with Contracts</h2>

When it comes to the concern of verification of contractual conditions (i.e. preconditions, postconditions and invariants), this is
commonly tangled with the implementation of the class itself. For instance consider the following class:

<pre>
  class SimpleClass {
  public:
    Init() {
      // do initialization
    }
    void DoSomething() {
      // precondition: object must be initialized
      // do something
    }
  }
</pre>

There is here an implied precondition to calling <tt>DoSomething()</tt> which is that the member function <tt>Init()</tt> must have been previously
called on a particular instance. A common and somewhat naive approach to assuring the precondition is done by introducing a member variable:

<pre>
  class SimpleClass {
  public:
    SimpleClass() : mbInit(false) {
    }
    Init() {
      // do initialization
      mbInit = true;
    }
    void DoSomething() {
      assert(mbInit);
      // do something
    }
  private:
    bool mbInit;
  }
</pre>

Notice that <tt>mbInit</tt> is solely used for verifying that the class is used correctly. The problem is that it probably will only be
needed during debug builds. The naive solution then would be:

<pre>
  class SimpleClass {
  public:
    SimpleClass()
#ifdef _DEBUG
      : mbInit(false)
#endif
    { }
    Init() {
#ifdef _DEBUG
      // do initialization
      mbInit = true;
#endif
    }
    void DoSomething() {
      assert(mbInit);
      // do something
    }
  private:
#ifdef _DEBUG
    bool mbInit;
#endif
  }
</pre>

Needlessly to say that is a mess. The problem results from a failure to separate concerns modularly. One improved solution is to
use inheritance:

<pre>
  class SimpleClass_with_contract : SimpleClass_impl {
  public:
    void SimpleClass_with_contract() : mbInit(false) {
    }
    void Init() {
      SimpleClass_impl::Init();
      mbInit = true;
    }
    void DoSomething() {
      assert(mbInit);
      SimpleClass_impl::DoSomething();
    }
  private:
    bool mbInit;
  };

  class SimpleClass_impl {
  public:
    void Init() {
      // do initialization
    }
    void DoSomething() {
      // do something
    }
  };

  #ifdef _DEBUG
    typedef SimpleClass_with_contract SimpleClass;
  #else
    typedef SimpleClass_impl SimpleClass;
  #endif
</pre>

This solution is good, but the contract verification class is not reusable because it is coupled with that particular implementation.
This arises because we have only partially separated the concern of contract verification.
Ideally I want something reusable, so I will use a class which inherits from its template parameters (a bolt-in).

<pre>
  template&lt;typename Impl_T&gt;
  class Simple_contract : Impl_T {
  public:
    void Simple_contract() : mbInit(false) {
    }
    void Init() {
      Impl_T::Init();
      mbInit = true;
    }
    void DoSomething() {
      assert(mbInit);
      Impl_T::DoSomething();
    }
  private:
    bool mbInit;
  };

  class SimpleClass_impl {
  public:
    void Init() {
      // do initialization
    }
    void DoSomething() {
      // do something
    }
  };

  #ifdef _DEBUG
    struct SimpleClass :
      Simple_contract&lt;SimpleClass&gt;
    { };
  #else
    struct SimpleClass :
      SimpleClass_impl
    { };
  #endif
</pre>

This new contract verification class can now be used with other classes with similar interfaces:

<pre>
  class AnotherSimpleClass_impl {
  public:
    void Init() {
      // do initialization
    }
    void DoSomething() {
      // do something
    }
  };

  #ifdef _DEBUG
    struct AnotherSimpleClass :
      Simple_contract&lt;AnotherSimpleClass&gt;
    { };
  #else
    typedef AnotherSimpleClass_impl AnotherSimpleClass;
  #endif
</pre>

This demonstrates how through the diligent practice of separation of concerns we can arrive at code which is more reusable.

<h2>Extension Classes</h2>

The public member functions of many classes can be divided up into two relatively distinct groups, core functions
and derived functions. The derived functions can be thought of as syntactic sugar, that is functions which can be
defined in terms of the core functions. These derived functions are a good candidate to use within a bolt-in. Consider
the case of the following naive and minimalist string implementation:

<pre>
  class MyString_impl {
  public:
    void SetCount(int n) {
      m.resize(n);
    }
    void SetChar(int n, char c) {
      m[n] = c;
    }
    char GetChar(int n) const {
      return m[n];
    }
    int Count() {
      return m.size();
    }
  private:
    std::vector&lt;char&gt; m;
  };
</pre>

This class is too minimalist to be of much use as-is, however with this basic implementation you can implement virtually every other
concievable string member function. By writing the derived functions within a bolt-in, I can reuse the derived set of memember functions
on any class which matches the code interface. For instance consider the following bolt-in:

<pre>
  template&lt;typename Impl_T&gt;
  class String_ext : public Impl_T {
  public:
    void Concat(const Impl_T&amp; x) {
      int n = Count();
      SetCount(n + x.Count());
      for (int i=n; &lt; Count(); i++) {
        SetChar(i, x.GetChar(i-n));
      }
    }
    void Assign(const Impl_T&amp; x) {
      SetCount(x.Count());
      for (int i=0; i &lt; Count(); i++) {
        SetChar(i, x.GetChar());
      }
    }
    Impl_T SubString(int n, int cnt) const {
      Impl_T s;
      s.SetCount(cnt);
      for (int i=0; i &lt; cnt; i++) {
        s.SetChar(i, GetChar(i + n));
      }
      return s;
    }
    // and so on and so forth
  };
</pre>

This extension class can be bolted on to any compatible class implementation as simply as:

<pre>
  typedef String_ext&lt;MyString_impl&gt; MyString;
</pre>

The advantage of doing this is that the extension class can be reused on any class matching the
core interface. This also reduces the coupling between extension functions and the implementation
to a set of four functions. Refactoring and debugging the code as a result becomes much easier.
<p>
We can also define a contract verification class for MyString as follows:

<pre>
  template&lt;typename Impl_T&gt;
  class String_contract : public Impl_T {
  public:
    void SetChar(int n, char c) {
      assert(n &lt; Count());
      Impl_T::SetChar(n);
      assert(GetChar(n) == c);
    }
    char GetChar(int n) const {
      assert(n &lt; Count());
      return Impl_T::GetChar(n);
    }
  }
</pre>

Tying everything together gives us:

<pre>
  #ifdef _DEBUG
    typedef String_ext&lt;String_contract&lt;MyString_impl&gt; &gt; MyString;
  #else
    typedef String_ext&lt;MyString_impl&gt; MyString;
  #endif
</pre>
<h2>The Big Gotcha</h2>

Hopefully I have demonstrated the theoretical advantages of separating classes into reusable components as bolt-ins.
There is however a big problem with all of this, constructor inheritance. In C++ constructors are not inherited, which really
puts a wrench in the gears (and makes me wish I was working with Heron instead of C++).
<p>
One solution I am aware of is to use template constructors. This is not a perfect solution though.
<p>
My currently preferred solution to this design conundrum is to forego initializing construction entirely within my libraries.
A rather drastic and contentious measure, but perhaps one which may pay off, because it opens the door more widely to sophisticated usage
of template parameter inheritance techniques such as bolt-ins, contract verificiation classes, extensions classes, and more.
Some debate on the merits of this approach can be found in the comments of my earlier blog entry
<a href="../_/http/www.artima.com/weblogs/viewpost.html$/thread=106524.html">Two Stage Construction in C++ versus Initializing Constructors</a>
<h1>Talk Back!</h1>
<p>
Have an opinion?


Readers have already posted

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=106760.html">16

comments</a>
about this weblog entry. Why not

<a href="../_/https/www.artima.com/forums/post.html$/forum=106&amp;thread=106760&amp;reply=true.html">add yours</a>?


<h1>RSS Feed</h1>
<p>
If you'd like to be notified whenever Christopher Diggins adds a new entry to <a href="../index.html$/blogger=cdiggins.html">his weblog</a>, subscribe to his <a href="../feeds/bloggers/cdiggins.rss">RSS feed</a>.

<center>
<div class="sociallinks">
<a href="../_/http/digg.com/submit$/phase=2&amp;url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D106760&amp;title=Bolt-Ins+for+Contract+and+Extension+Classes&amp;bodytext=At+Matthew+Wilson%27s+behest%2C+I+have+attempted+to+further+explain+my+rationale+behind+separate+extension+classes%2C+and+contract+verification+classes.+It+turns+out+they+fit+very+nicely+in+a+design+pattern+which+Matthew+refers+to+as+a+bolt-in.&amp;topic=programming">
<img alt="Digg" border="0" height="14" hspace="8" src="../_/https/www.artima.com/images/digg.gif" width="16">Digg
  </img></a>
  |
  <a href="../_/http/del.icio.us/post$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D106760&amp;title=Bolt-Ins+for+Contract+and+Extension+Classes">
<img alt="del.icio.us" border="0" height="16" hspace="8" src="../_/https/www.artima.com/images/delicious.gif" vspace="1" width="16">del.icio.us
  </img></a>
  |
  <a href="../_/http/programming.reddit.com/submit$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D106760&amp;title=Bolt-Ins+for+Contract+and+Extension+Classes">
<img alt="Reddit" border="0" height="18" hspace="8" src="../_/https/www.artima.com/images/reddit.gif" width="18"/>Reddit
  </a>
</div>
</center>
<h1>About the Blogger</h1>
<p>
<table><tr valign="bottom"><td><img align="right" src="../_/https/www.artima.com/images/christopherdiggins.jpg"/></td><td>Christopher Diggins is a software developer and freelance writer. Christopher loves programming, but is eternally frustrated by the shortcomings of modern programming languages. As would any reasonable person in his shoes, he decided to quit his day job to write his own ( <a href="../_/http/www.heron-language.com/index.html">www.heron-language.com</a> ). Christopher is the co-author of the <a href="../_/http/www.cpp-cookbook.com/index.html">C++ Cookbook</a> from O'Reilly. Christopher can be reached through his home page at  <a href="../_/http/www.cdiggins.com/index.html">www.cdiggins.com</a>.</td></tr></table><p>
<div class="sp">This weblog entry is Copyright © 2005 Christopher Diggins. All rights reserved.</div>
</p></p></p></p></p></p></p></p></p></p></div>

<hr width="100%">
<table align="center" width="50%">
<tr>
<td>
<div class="horizontaltextadbox">
<div class="adheadline">Sponsored Links</div>
<div id="sponsoredlinks">
</div>
</div>
</td>
</tr>
</table>
<hr width="100%"/>
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script src="../_/https/pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
</script>
<br>
<br/>
<!-- SiteSearch Google -->
<form action="../_/https/www.google.com/custom/index.html" method="get">
<table bgcolor="#ffffff" border="0">
<tr><td align="left" height="32" nowrap="nowrap" valign="top">
<a href="../_/https/www.google.com/index.html">
<img alt="Google" border="0" src="../_/https/www.google.com/logos/Logo_25wht.gif"/></a>
</td>
<td nowrap="nowrap">
<input name="domains" type="hidden" value="Artima.com"/>
<input maxlength="255" name="q" size="31" type="text" value=""/>
<input name="sa" type="submit" value="Search"/>
</td></tr>
<tr>
<td> </td>
<td nowrap="nowrap">
<font color="#000000" size="-1">
<input name="sitesearch" type="radio" value=""/> Web
<input checked="checked" name="sitesearch" type="radio" value="Artima.com"/>Artima.com
</font>  
<input name="client" type="hidden" value="pub-3911176865765226"/>
<input name="forid" type="hidden" value="1"/>
<input name="ie" type="hidden" value="ISO-8859-1"/>
<input name="oe" type="hidden" value="ISO-8859-1"/>
<input name="cof" type="hidden" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;"/>
<input name="hl" type="hidden" value="en"/>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</br></center>
<br/>
<div class="sp">
<div style="text-align: center;">
<a href="../_/https/www.artima.com/copyright.html">Copyright</a> © 1996-2019 Artima, Inc. All Rights Reserved. - <a href="../_/https/www.artima.com/privacy.html">Privacy Policy</a> - <a href="../_/https/www.artima.com/termsofuse.html">Terms of Use</a>
</div>
</div>
<br/>
<script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = '../_/https/www.artima.com/zcr/index.html' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(3);
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('leftskyscraper');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>
</hr><a href="https://dafoster.net/projects/crystal-web-archiver/" id="cr-footer-banner" style="border-top: 2px #B40010 solid;background: #FFFAE1;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant: initial;font-weight: initial;text-transform: none;font-size: 14px;color: #6c757d;line-height: 2.0;cursor: pointer;display: flex;align-items: center;justify-content: center;gap: 4px;clear: both;" target="_blank"><img height="24" onerror="this.style['display'] = 'none';" src="../_/crystal/resources/appicon.png" width="24"/><span>This page was archived with Crystal</span><script>window.addEventListener('load', function() { const $1 = document.querySelector('#cr-footer-banner'); if (!$1) { return; } if (window !== window.top) { let $2 = false; if (window.name) { const $3 = window.parent.document.getElementsByName(window.name); if ($3.length === 1) { const $4 = $3[0]; if ($4.tagName === 'FRAME' && $4.parentElement.tagName === 'FRAMESET') { let $5 = $4; while (true) { if ($5.parentElement.tagName !== 'FRAMESET') { $2 = true; break; } if ($5.parentElement.attributes['rows'] !== undefined) { const $6 = $5.parentElement.children; if ($5 === $6[$6.length - 1]) { $5 = $5.parentElement; continue; } else { break; } } else if ($5.parentElement.attributes['cols'] !== undefined) { const $7 = Array.from($5.parentElement.children); const $8 = $7.indexOf($5); if ($8 === -1) { break; } const $9 = $5.parentElement.attributes['cols'].value.split(','); const $10 = $9.map((s) => parseInt(s.trim())); if ($9[$8].trim() === '*' || $10[$8] === Math.max.apply(null, $10)) { $5 = $5.parentElement; continue; } else { break; } } else { break; } } } } } if (!$2) { $1.style['display'] = 'none'; } } const $11 = $1.getBoundingClientRect(); const $12 = ($11.y < window.innerHeight - $11.height); if ($12) { $1.style['position'] = 'fixed'; $1.style['bottom'] = '0'; $1.style['left'] = '0'; $1.style['right'] = '0'; $1.style['z-index'] = '9999'; } const $13 = ( document.body.getBoundingClientRect().height < $11.height * 2 ); if ($13) { $1.style['display'] = 'none'; }
});</script></a></body>
</html>
