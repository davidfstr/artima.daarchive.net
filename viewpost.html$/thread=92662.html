
<!DOCTYPE html>

<html>
<head><meta content="noindex,nofollow" name="robots"/>
<title>Interfaces or Abstract Base Classes?</title>
<meta charset="utf-8"/>
<meta content="Guido van van Rossum" name="author">
<link href="../_/https/www.artima.com/artima.css" rel="stylesheet" type="text/css"/>
<link href="../_/https/www.artima.com/favicon.ico" rel="shortcut icon"/>
</meta></head>
<body><table cellspacing="0" width="100%">
<tr>
<td align="left" valign="bottom">
<a href="../_/https/www.artima.com/index.html"><img alt="The Artima Developer Community" border="0" height="43" src="../_/https/www.artima.com/images/a7.gif" width="550"/></a>
</td>
</tr></table>
<table bgcolor="#333333" width="100%">
<tr>
<td align="center">
<div class="ml">
<a class="hl" href="../_/https/www.artima.com/articles/index.html">Articles</a> |
<a class="hl" href="../_/https/www.artima.com/news/index.html">News</a> |
<a class="hl" href="../index.html">Weblogs</a> |
<a class="hl" href="../_/https/www.artima.com/shop/catalog/index.html">Books</a> |
<a class="hl" href="../_/https/www.artima.com/forums/index.html">Forums</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#AACCFF" width="100%">
<tr>
<td align="center">
<div class="sc">
<a href="../index.html">Artima Weblogs</a> | 

<a href="../index.html$/blogger=guido.html">Guido van van Rossum's Weblog</a> | 

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=92662.html">Discuss</a> | 
<a href="mailto:?subject=Interfaces or Abstract Base Classes?&amp;body= %0AArtima Weblogs %0AInterfaces or Abstract Base Classes? %0Aby Guido van van Rossum %0A%0Ahttps://www.artima.com/weblogs/viewpost.jsp?thread=92662">Email</a> | 
<a href="../viewpostP.html$/thread=92662.html">Print</a> | 
<a href="../bloggers.html">Bloggers</a> | 
<a class="sl" href="thread=101968.html" title="Stricter Whitespace Enforcement">Previous</a> | 
<a class="sl" href="thread=122250.html" title="M Clock 2.0">Next</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#EEEEEE" width="100%">
<tr>
<td align="center">
<div class="sc">
<span style="color: #555555;">Sponsored Link</span> <span style="color: #888888;">•</span>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a799ecf6.html" target="_top"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:9&amp;n=a0587811.html"/></a></noscript>
</div>
</td>
</tr>
</table>
<br/>
<div class="vegies">
<div class="tc">
<span class="sts">All Things Pythonic</span><br>
<span class="ts">Interfaces or Abstract Base Classes?</span><br/>
<span class="as">by Guido van van Rossum</span><br/>
<span class="pd">August 5, 2005</span><br/>
</br></div>
<blockquote>
<b>Summary</b><br/>
I found this in my drafts, dated Feb 6 2005.  I 'll just push it out now unedited.  Original summary:
I thought it was clear that we should add interfaces to Python, but Phillip Eby reminded me that years ago I rejected them in favor of Abstract Base Classes (ABCs).  Why?  I don't remember!  Which do you prefer?

</blockquote>
<hr align="left" width="90%"/>
<table align="right">
<tr>
<td>
<div class="adnotice">
Advertisement
</div>
<center>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
if (!document.phpAds_used) document.phpAds_used = ',';
phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
document.write ("&amp;what=zone:2");
document.write ("&amp;exclude=" + document.phpAds_used);
if (document.referrer)
document.write ("&amp;referer=" + escape(document.referrer));
document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a74ab060.html" target="_blank"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:2&amp;n=a74ab060.html"/></a></noscript>
</center>
</td>
</tr>
</table>
<p>
<div class="section" id="abcs-vs-interfaces">
<h1><a name="abcs-vs-interfaces">ABCs vs. Interfaces</a></h1>
<p>I can't for the life of me remember why I would prefer ABCs over
interfaces!  And even if I did remember, I believe I have changed my
mind since then.</p>
<p>The only argument that comes to mind is that ABCs don't require more
syntax.  That's usually a strong argument in Python.  But it seems
that at least two of the largest 3rd party projects in Python (Zope
and Twisted) have already decided that they can't live without
interfaces, and have created their own implementation.  From this I
conclude that there's a real need.</p>
<p>But if they can do it themselves (albeit with some heavy-duty
metaclass magic), doesn't that prove we don't have to add them to the
language?  Not at all.  The mechanisms used are ideosyncratic,
fragile, and cumbersome.  For example, you have to use __xxx__ words
to declare conformance to an interface.  Plus, there's duplicate work
and interoperability.  IMO this is language infrastructure that should
be provided by the language implementation.</p>
<p>Many followups to my blogs about adding optional type checking to
Python (given the latest design I'm leaving off the word "static" :-)
said that interfaces were more important than type checking.
Personally, I think they're interconnected: interfaces make much more
sense if you can also declare the argument types of the methods, and
argument type declarations in Python are unthinkable without a way to
spell duck types -- for which interfaces are an excellent approach.
Phillip Eby's Monkey Typing proposal is an interface-free alternative,
but I find it way too complex to be adopted as a standard Python
mechanism.</p>
<p>A few more arguments against ABCs: they seem the antithesis of duck
typing.  Using ABCs for type declarations suggests that isinstance()
is used for type checking, and even if reality is not quite that
rigid, this suggestion would be leading people into the wrong
direction.</p>
<p>ABCs also allow, nay, encourage, "partially abstract" classes --
classes that have some abstract methods and some concrete ones.  Of
course, such a class as a whole is still abstract, but the resulting
mixture of implementation and interface complexifies the semantics.</p>
<p>It has been suggested, especially by Ping, that there is a need to
specify some semantics in interfaces.  A typical example involves a
file, where various operations such as readline() and readlines(), can
be implemented by default in terms of a more primitive operation -- in
this case read().  Unfortunately, I believe that this approach is not
very practical, since those default implementations are usually
inefficient, and the choice of the "most primitive" operation is often
dependent on the situation.  I also suspect that outside some common
standard types there aren't all that many uses for this pattern.  But
if you have to do this, a mix-in class for the "default" functionality
separate from the interface would work just as well as combining the
two.</p>
<p>Specifically because they are not classes, interfaces allow for clear,
distinct semantics.  (That is, the semantics of interface objects; I
intend for interfaces to be neutral on the issue of the semantics of
the objects they describe.)  For example, (not that I necessarily
propose this, but this is one way that we could decide to go), in a
class claiming to implement a particular method declared in an
interface, it could be flagged as an error if the actual
implementation required more arguments than declared in the interface,
or (assuming we can have type declarations in interfaces as well as in
classes) if the argument types didn't match.</p>
<p>Python has a strong tradition that subclasses may redefine methods
with a different signature, and making that an error goes against the
grain of the language.  But the explicit use of an interface changes
things and there is seems appropriate that a class should not be
allowed to violate an interface it claims to implement.</p>
<p>So, while I haven't decided that Python 3.0 will have interfaces (or
type declarations), I'd like to go ahead and hypothesize about such a
future, and look at some of the standard interfaces the language would
provide for various common protocols like sequence, mapping and file.</p>
</div>
<div class="section" id="the-file-interface">
<h1><a name="the-file-interface">The File Interface</a></h1>
<p>Let's start with files, because they don't require genericity to fully
specify the interface.  Here's my first attempt.  Note that I'm
simplifying a few things; I'd like to drop the optional argument to
readline() and readlines(), and I'm dropping the obsolete API
xreadlines():</p>
<pre class="literal-block">
interface file:

    def readline() -&gt; str:
        "Returns the next line; returns '' on EOF"

    def next() -&gt; str:
        """Returns the next line; raises StopIteration on EOF.

        next() has one special property: due to internal buffering,
        mixing it with other operations is not guaranteed to work
        properly unless seek() is called first.

        """

    def __iter__() -&gt; file:
        "Returns self"

    def read(n: int = -1) -&gt; str:
        """Reads n bytes; if n &lt; 0, reads until EOF.

        This blocks rather than returning a short read unless EOF is
        reached; however not all implementations honor this
        property.

        (Did you know the default argument was -1?)

        """

    def readlines() -&gt; list[str]:
        "Returns a list containing the remaining lines"

    def seek(pos: int, how: int = 0) -&gt; None:
        """Sets the position for the next read/write.

        The 'how' argument should be 0 for positioning relative to
        the start of the file, 1 for positioning relative to the
        current position, and 2 for positioning relative to the end
        of the file.

        """

    def tell() -&gt; int:
        "Returns the current read/write position"

    def write(s: str) -&gt; None:
        "Writes a string"

    def writelines(s: list[str]) -&gt; None:
        """Writes a list of strings.

        Note: this does not add newlines; the strings in the list
        are supposed to end in a newline.

        """

    def truncate(size: int = ...) -&gt; None:
        """Truncates the file to the given size.

        Default is the current position.

        """

    def flush() -&gt; None:
        "Flushes buffered data to the operating system."

    def close():
        "Closes the file, rendering subsequent use invalid"

    def fileno() -&gt; int:
        """Returns the underlying 'Unix file descriptor'.

        Not all file implementations may support this, and the
        semantics are not always the same.

        """

    def isatty() -&gt; bool:
        "Returns whether this is an interactive device"

    # Attributes

    softspace: int # read-write attribute used by 'print'

    # The following are read-only and not always supported

    mode: str # mode given to open

    name: str # file name given to open

    encoding: str|None # file encoding

    closed: bool # whether the file is closed

    newlines: None|str|tuple(str) # observed newline convention
</pre>
<p>This brings up a number of interesting issues already:</p>
<blockquote>
<ul>
<li><p class="first">The file interface does <em>not</em> include standard object methods and
attributes such as __repr__() and __class__.  But it <em>does</em>
include __iter__() since this is not supported by all objects.</p>
</li>
<li><p class="first">Moreover __iter__() is defined different than the "generic"
definition of __iter__() would be: since we know that a file's
__iter__ method returns the file itself, we know its type.  This
is in general the case for standard APIs that are explicitly
part of a specific interface; we'll see this again for
__getitem__ later.</p>
</li>
<li><p class="first">The argument to writelines() and the return value from
readlines() are lists of strings.  I really want to be able to
express that in the interface definition.  Even in Pascal,
which has such a nice simple type system, you can say this!
I'm using list[str], following the notation I used in an earlier
blog where I was brainstorming about generic types.</p>
</li>
<li><p class="first">Rather than distinguishing between None and its type, for
conciseness I'm using the singleton value as its own type.
While type(None) is not None and never will be, in type
expressions, None stands for type(None).</p>
</li>
<li><p class="first">In a few places, a value may be either a string or None; or
either an int or None.  I'm using the notation str|None
respectively int|None for this, which also debuted in an earlier
blog.</p>
</li>
<li><p class="first">The argument to truncate() has a dynamic default.  I'm proposing
the notation ... for this; I don't want to say -1 because
passing int -1 doesn't have the same effect, unlike for read().
The semantics of this notation are that an implementation may
choose its own default but that it must provide one.</p>
</li>
<li><p class="first">There's the thorny issue of some APIs that aren't always
defined.  I'm not going to introduce a notation for this yet;
rather, I'll just say it in a comment.  The default type
checking algorithm will accept partial implementations of an
interface.</p>
</li>
<li><p class="first">The file interface has a few attributes, one of which
(softspace) is writable.  This <em>must</em> be supported or else the
print statement won't work righty when directed to such a file.
For now I'm using the notation:</p>
<pre class="literal-block">
name: type
</pre>
<p>and indicating the read-write-ness in a comment.  The notation
is less than ideal because it doesn't allow to attach a doc
string.  I could use this:</p>
<pre class="literal-block">
name: type "docstring"
</pre>
<p>but I fear that Python's parser isn't smart enough to always
know where the type expression ends and the docstring begins
(since 'type' can be an expression, syntactically).</p>
</li>
<li><p class="first">Note that softspace is conceptually a bool, but implemented as
an int, and that's how it's declared here.</p>
</li>
<li><p class="first">The return type of close() is problematic.  Usually it is None,
but for file objects returned by os.popen() is is an int.  I've
chosen to leave out the '-&gt; None' notation on the close()
method, leaving its return type unspecified.  I could also have
written '-&gt; int|None'.  Or we could have a rule that allows
a method that is declared to return None to return a different
type, perhaps after subclassing.</p>
</li>
<li><p class="first">It would be lovely to be able to declare exceptions, even if we
don't assign any semantics to this (Java checked exceptions have
turned out to be a horrible thing in practice).  But I'm leaving
this to a future brainstorm.</p>
</li>
<li><p class="first">What about argument names and keyword parameters?  In the above
example, I don't intend to allow keyword parameters on any of
the interfaces.  But what if an interface <em>wants</em> to define
keyword parameters?  What if you want to <em>require</em> certain
parameters to be given as keyword parameters (and you still want
to declare their types)?  Maybe we need a notation to explicitly
say that an argument can or must be a keyword parameter?  Or
maybe it would be sufficient to allow leaving out the parameter
name if it is supposed to be always positional?  Then the
declaration of read() would become:</p>
<pre class="literal-block">
def read(:int = -1) -&gt; str: "reads some bytes [...]"
</pre>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="the-sequence-interface">
<h1><a name="the-sequence-interface">The Sequence Interface</a></h1>
<p>Here's my attempt at defining a generic sequence interface.  Note that
I'm declaring this as a generic type, with 'T' being the type
parameter.  This despite my earlier promise not to bother with generic
types.  I think they are both useful and easy to implement, even if
there are some thorny issues left: a dynamic check for list[int] is
very expensive (it has to check every item in the list for int-ness)
and any mutation of the list might change its type:</p>
<pre class="literal-block">
interface iterator[T]:

    def __iter__() -&gt; iterator[T]: "returns self"

    def next() -&gt; T: "returns the next item or raises StopIteration"

interface iterable[T]:

    """An iterable should preferably implement __iter__().

    __getattr__() is a fallback in case __iter__ is not defined.

    Note that an iterator is a perfect candidate for an iterable, by
    virtue of its __iter__() method.

    """

    def __iter__() -&gt; iterator[T]: "returns an iterator"

    def __getitem__(i: int) -&gt; T: "returns an item"

interface sequence[T]:

    @overloaded
    def __getitem__(i: int) -&gt; T: "gets an item"

    @overloaded
    def __setitem__(i: int, x: T) -&gt; None: "sets an item"

    @overloaded
    def __delitem__(i: int) -&gt; None: "deletes an item"

    def __iter__() -&gt; iterator[T]: "returns iterator"

    def __reversed__() -&gt; iterator[T]: "returns reverse iterator"

    def __len__(): int: "returns number of items"

    def __contains__(x: T): bool: "returns whether x in self"

    def __getslice__(lo: int, hi: int) -&gt; sequence[T]:
        "gets a slice"

    def __setslice__(lo: int, hi: int, xs: iterable[T]) -&gt; None:
        "sets a slice"

    @overloaded
    def __getitem__(x: slice) -&gt; sequence[T]:
        "gets an extended slice"

    @overloaded
    def __setitem(x: slice, xs: iterable[T]) -&gt; None:
        "sets an extended slice"

    @overloaded
    def __delitem__(x: slice) -&gt; None:
        "deletes an extended slice"

    def __add__(x: iterable[T]) -&gt; sequence[T]:
        "concatenation (+)"

    def __radd__(x: iterable[T]) -&gt; sequence[T]:
        "right-handed concatenation (+)"

    def __iadd__(x: iterable[T]) -&gt; sequence[T]:
        "in-place concatenation (+=)"

    def __mul__(n: int) -&gt; sequence[T]: "repetition (*)"

    def __rmul__(n: int) -&gt; sequence[T]: "repetition (*)"

    def __imul__(n: int) -&gt; sequence[T]: "in-place repetition (*=)"

    # The rest are all list methods -- should we really define these?

    def append(x: T) -&gt; None: "appends an item"

    def insert(i: int, x: T) -&gt; None: "inserts an item"

    def extend(xs: iterable[T]) -&gt; None: "appends several items"

    def pop(i: int = -1) -&gt; T: "removes and return an item"

    def remove(x: T) -&gt; None:
        "removes an item by value; may raise ValueError"

    def index(x: T) -&gt; int:
        "returns first index where item is found; may raise ValueError"

    def count(x: T) -&gt; int: "returns number of occurrences"

    def reverse() -&gt; None: "in-place reversal"

    # But not sort() -- that's really only a list method
</pre>
<p>Some additional issues with this:</p>
<blockquote>
<ul class="simple">
<li>The syntax for declaring a generic interface (interface X[T])
requires a bit of a leap of faith.  But without parameterization
we can say so much less about a sequence than what is common
knowledge (and what a type inferencer should know) that I find
it nearly useless to bother defining a sequence type without
this notation.  Possibly an implementation that ignores the type
parameter T would be acceptable; use of T would be purely for
the benefit of the human reader.</li>
<li>I had to introduce two auxiliary interfaces:<ul>
<li>iterator, something with primarily a next() method</li>
<li>iterable: something with primarily an __iter__() method,
although something implementing __getitem__() will also work.
That makes its declaration a bit awkward (with both methods
being optional but at least one being required).</li>
</ul>
</li>
<li>I struggled a bit with the two possible signatures for
__getitem__ and friends: it is normally called with an int
argument, returning a single item, but the extended slice
notation (e.g. seq[1:2:3]) calls it with an argument that is a
slice object, and then it returns a sequence.  Declaring the
argument and return types as unions feels unsatisfactory because
it throws away information.  I decided to use the @overloaded
decorator, which can be implemented using a small amount of
namespace hacking.</li>
<li>Should we have separate interfaces for immutable and mutable
sequences?  For now I'd rather only have one; the notion that an
implementation may leave out methods naturally allows for
immutable sequences.</li>
<li>Should the sequence interface mention virtually everything that
a list can do, or should it be minimal?</li>
<li>Even if the sequence interface is inclusive (containing most
list methods), I'd like to leave sort() out of it; sort() is
really unique to the list type, and even if some user type
defines a sort() method, it's unlikely to have the same
signature as list.sort() (especially after what we did to this
signature in Python 2.4).  Feel free to prove me wrong.</li>
<li>In current Python, the + operator on standard sequence types
only accepts a right operand of the same type (list, tuple or
str).  But the += operator on a list accepts any iterable!  I
think + on any two sequences, or even a sequence and an
iterable, in either order, should be allowed, and should return
a new sequence.  However, iterable + iterable should be left
undefined; this is because iterator + iterator is not defined,
and I think it should not be.</li>
</ul>
</blockquote>
</div>
<div class="section" id="the-mapping-type">
<h1><a name="the-mapping-type">The Mapping Type</a></h1>
<p>XXX</p>
</div>
<h1>Talk Back!</h1>
<p>
Have an opinion?


Readers have already posted

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=92662.html">42

comments</a>
about this weblog entry. Why not

<a href="../_/https/www.artima.com/forums/post.html$/forum=106&amp;thread=92662&amp;reply=true.html">add yours</a>?


<h1>RSS Feed</h1>
<p>
If you'd like to be notified whenever Guido van van Rossum adds a new entry to <a href="../index.html$/blogger=guido.html">his weblog</a>, subscribe to his <a href="../feeds/bloggers/guido.rss">RSS feed</a>.

<center>
<div class="sociallinks">
<a href="../_/http/digg.com/submit$/phase=2&amp;url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D92662&amp;title=Interfaces+or+Abstract+Base+Classes%3F&amp;bodytext=I+found+this+in+my+drafts%2C+dated+Feb+6+2005.++I+%27ll+just+push+it+out+now+unedited.++Original+summary%3A%0D%0AI+thought+it+was+clear+that+we+should+add+interfaces+to+Python%2C+but+Phillip+Eby+reminded+me+that+years+ago+I+rejected+them+in+favor+of+Abstract+Base+_&amp;topic=programming">
<img alt="Digg" border="0" height="14" hspace="8" src="../_/https/www.artima.com/images/digg.gif" width="16">Digg
  </img></a>
  |
  <a href="../_/http/del.icio.us/post$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D92662&amp;title=Interfaces+or+Abstract+Base+Classes%3F">
<img alt="del.icio.us" border="0" height="16" hspace="8" src="../_/https/www.artima.com/images/delicious.gif" vspace="1" width="16">del.icio.us
  </img></a>
  |
  <a href="../_/http/programming.reddit.com/submit$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D92662&amp;title=Interfaces+or+Abstract+Base+Classes%3F">
<img alt="Reddit" border="0" height="18" hspace="8" src="../_/https/www.artima.com/images/reddit.gif" width="18"/>Reddit
  </a>
</div>
</center>
<h1>About the Blogger</h1>
<p>
<table><tr valign="bottom"><td><img align="right" src="../_/https/www.artima.com/images/guido.jpg"/></td><td>Guido van Rossum is the creator of Python, one of the major
programming languages on and off the web. The Python community refers to him as the BDFL (Benevolent Dictator For Life), a title straight
from a Monty Python skit. He moved from the Netherlands to the USA in
1995, where he met his wife. Until July 2003 they lived in the
northern Virginia suburbs of Washington, DC with their son Orlijn, who
was born in 2001. They then moved to Silicon Valley where Guido now works for Google
(spending 50% of his time on Python!).</td></tr></table><p>
<div class="sp">This weblog entry is Copyright © 2005 Guido van van Rossum. All rights reserved.</div>
</p></p></p></p></p></div>

<hr width="100%">
<table align="center" width="50%">
<tr>
<td>
<div class="horizontaltextadbox">
<div class="adheadline">Sponsored Links</div>
<div id="sponsoredlinks">
</div>
</div>
</td>
</tr>
</table>
<hr width="100%"/>
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script src="../_/https/pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
</script>
<br>
<br/>
<!-- SiteSearch Google -->
<form action="../_/https/www.google.com/custom/index.html" method="get">
<table bgcolor="#ffffff" border="0">
<tr><td align="left" height="32" nowrap="nowrap" valign="top">
<a href="../_/https/www.google.com/index.html">
<img alt="Google" border="0" src="../_/https/www.google.com/logos/Logo_25wht.gif"/></a>
</td>
<td nowrap="nowrap">
<input name="domains" type="hidden" value="Artima.com"/>
<input maxlength="255" name="q" size="31" type="text" value=""/>
<input name="sa" type="submit" value="Search"/>
</td></tr>
<tr>
<td> </td>
<td nowrap="nowrap">
<font color="#000000" size="-1">
<input name="sitesearch" type="radio" value=""/> Web
<input checked="checked" name="sitesearch" type="radio" value="Artima.com"/>Artima.com
</font>  
<input name="client" type="hidden" value="pub-3911176865765226"/>
<input name="forid" type="hidden" value="1"/>
<input name="ie" type="hidden" value="ISO-8859-1"/>
<input name="oe" type="hidden" value="ISO-8859-1"/>
<input name="cof" type="hidden" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;"/>
<input name="hl" type="hidden" value="en"/>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</br></center>
<br/>
<div class="sp">
<div style="text-align: center;">
<a href="../_/https/www.artima.com/copyright.html">Copyright</a> © 1996-2019 Artima, Inc. All Rights Reserved. - <a href="../_/https/www.artima.com/privacy.html">Privacy Policy</a> - <a href="../_/https/www.artima.com/termsofuse.html">Terms of Use</a>
</div>
</div>
<br/>
<script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = '../_/https/www.artima.com/zcr/index.html' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(3);
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('leftskyscraper');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>
</hr><a href="https://dafoster.net/projects/crystal-web-archiver/" id="cr-footer-banner" style="border-top: 2px #B40010 solid;background: #FFFAE1;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant: initial;font-weight: initial;text-transform: none;font-size: 14px;color: #6c757d;line-height: 2.0;cursor: pointer;display: flex;align-items: center;justify-content: center;gap: 4px;clear: both;" target="_blank"><img height="24" onerror="this.style['display'] = 'none';" src="../_/crystal/resources/appicon.png" width="24"/><span>This page was archived with Crystal</span><script>window.addEventListener('load', function() { const $1 = document.querySelector('#cr-footer-banner'); if (!$1) { return; } if (window !== window.top) { let $2 = false; if (window.name) { const $3 = window.parent.document.getElementsByName(window.name); if ($3.length === 1) { const $4 = $3[0]; if ($4.tagName === 'FRAME' && $4.parentElement.tagName === 'FRAMESET') { let $5 = $4; while (true) { if ($5.parentElement.tagName !== 'FRAMESET') { $2 = true; break; } if ($5.parentElement.attributes['rows'] !== undefined) { const $6 = $5.parentElement.children; if ($5 === $6[$6.length - 1]) { $5 = $5.parentElement; continue; } else { break; } } else if ($5.parentElement.attributes['cols'] !== undefined) { const $7 = Array.from($5.parentElement.children); const $8 = $7.indexOf($5); if ($8 === -1) { break; } const $9 = $5.parentElement.attributes['cols'].value.split(','); const $10 = $9.map((s) => parseInt(s.trim())); if ($9[$8].trim() === '*' || $10[$8] === Math.max.apply(null, $10)) { $5 = $5.parentElement; continue; } else { break; } } else { break; } } } } } if (!$2) { $1.style['display'] = 'none'; } } const $11 = $1.getBoundingClientRect(); const $12 = ($11.y < window.innerHeight - $11.height); if ($12) { $1.style['position'] = 'fixed'; $1.style['bottom'] = '0'; $1.style['left'] = '0'; $1.style['right'] = '0'; $1.style['z-index'] = '9999'; } const $13 = ( document.body.getBoundingClientRect().height < $11.height * 2 ); if ($13) { $1.style['display'] = 'none'; }
});</script></a></body>
</html>
