
<!DOCTYPE html>

<html>
<head><meta content="noindex,nofollow" name="robots"/>
<title>Trees and Labelled S-Expressions</title>
<meta charset="utf-8"/>
<meta content="Christopher Diggins" name="author">
<link href="../_/https/www.artima.com/artima.css" rel="stylesheet" type="text/css"/>
<link href="../_/https/www.artima.com/favicon.ico" rel="shortcut icon"/>
</meta></head>
<body><table cellspacing="0" width="100%">
<tr>
<td align="left" valign="bottom">
<a href="../_/https/www.artima.com/index.html"><img alt="The Artima Developer Community" border="0" height="43" src="../_/https/www.artima.com/images/a7.gif" width="550"/></a>
</td>
</tr></table>
<table bgcolor="#333333" width="100%">
<tr>
<td align="center">
<div class="ml">
<a class="hl" href="../_/https/www.artima.com/articles/index.html">Articles</a> |
<a class="hl" href="../_/https/www.artima.com/news/index.html">News</a> |
<a class="hl" href="../index.html">Weblogs</a> |
<a class="hl" href="../_/https/www.artima.com/shop/catalog/index.html">Books</a> |
<a class="hl" href="../_/https/www.artima.com/forums/index.html">Forums</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#CCCCCC" width="100%">
<tr>
<td align="center">
<div class="sc">
<a href="../index.html">Artima Weblogs</a> | 

<a href="../index.html$/blogger=cdiggins.html">Christopher Diggins' Weblog</a> | 

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=135216.html">Discuss</a> | 
<a href="mailto:?subject=Trees and Labelled S-Expressions&amp;body= %0AArtima Weblogs %0ATrees and Labelled S-Expressions %0Aby Christopher Diggins %0A%0Ahttps://www.artima.com/weblogs/viewpost.jsp?thread=135216">Email</a> | 
<a href="../viewpostP.html$/thread=135216.html">Print</a> | 
<a href="../bloggers.html">Bloggers</a> | 
<a class="sl" href="thread=135003.html" title="Presenting a Simpler Alternative to XML: PicoML">Previous</a> | 
<a class="sl" href="thread=135425.html" title="A Problem involving the Syntax of Concepts in Heron">Next</a>
</div>
</td>
</tr>
</table>
<table bgcolor="#EEEEEE" width="100%">
<tr>
<td align="center">
<div class="sc">
<span style="color: #555555;">Sponsored Link</span> <span style="color: #888888;">•</span>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a799ecf6.html" target="_top"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:9&amp;n=a0587811.html"/></a></noscript>
</div>
</td>
</tr>
</table>
<br/>
<div class="vegies">
<div class="tc">
<span class="sts">Heron-Centric: Ruminations of a Language Designer</span><br>
<span class="ts">Trees and Labelled S-Expressions</span><br/>
<span class="as">by Christopher Diggins</span><br/>
<span class="pd">November 4, 2005</span><br/>
</br></div>
<blockquote>
<b>Summary</b><br/>
An enormous amount of data can be conveniently represented as a labelled tree. This is the basis of many markup languages such as SGML, XML, HTML, and others. Herein I propose an alternative, Labelled S-Expressions and provide code for a working parser in C++.

</blockquote>
<hr align="left" width="90%"/>
<table align="right">
<tr>
<td>
<div class="adnotice">
Advertisement
</div>
<center>
<script language="JavaScript" src="../_/https/www.artima.com/zcr/adx.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
if (!document.phpAds_used) document.phpAds_used = ',';
phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
document.write ("../_/https/www.artima.com/zcr/adjs.html$/n=.html" + phpAds_random);
document.write ("&amp;what=zone:2");
document.write ("&amp;exclude=" + document.phpAds_used);
if (document.referrer)
document.write ("&amp;referer=" + escape(document.referrer));
document.write ("'><" + "/script>");
//-->
</script><noscript><a href="../_/https/www.artima.com/zcr/adclick.html$/n=a74ab060.html" target="_blank"><img alt="" border="0" src="../_/https/www.artima.com/zcr/adview.html$/what=zone:2&amp;n=a74ab060.html"/></a></noscript>
</center>
</td>
</tr>
</table>
<p>
<a href="../_/http/theory.lcs.mit.edu/~rivest/sexp.html">S-Expressions</a> are a well known way of representing hierarchical
data-structures in text form, but they lack the extra information and structure which is gained by associating a label with a
data element.
<p>
Consider the following S-Expression:

<pre>
  (cd
    (title Maggie May)
    (artist Rod Stewart)
    (country UK)
    (company Pickwick)
    (price 8.50)
    (year 1990)
  )
</pre>

One drawback of the format is that the label is only identified as being the first element in the S-Expression.
The other problem is that white-space is significant as being a delimiter between labels and the rest of the data.
For textual data, it is important that white-space not be part of the grammar, otherwise subtle errors can easily arise. There is no standardized
S-Expression format, and each has different ways of grouping data. XML on the other hand is more structured.
The following is what the example data structure would look like as XML.

<pre>
  &lt;cd&gt;
    &lt;title&gt;Maggie May&lt;/title&gt;
    &lt;artist&gt;Rod Stewart&lt;/artist&gt;
    &lt;country&gt;UK&lt;/country&gt;
    &lt;company&gt;Pickwick&lt;/company&gt;
    &lt;price&gt;8.50&lt;/price&gt;
    &lt;year&gt;1990&lt;/year&gt;
  &lt;/cd&gt;
</pre>

XML however is very complex and slow and painful to parse. It is also verbose. Labelled S-Expressions provide
the best of both formats, while being extremely easy to parse.

<pre>
  (cd:
    (title:Maggie May)
    (artist:Rod Stewart)
    (country:UK)
    (company:Pickwick)
    (price:8.50)
    (year:1990)
  )
</pre>
<h3>Grammar</h3>

The precise syntax of the Labelled S-Expression format was inspired by <a href="../_/http/www.artima.com/forums/flat.html$/forum=106&amp;thread=135003.html">
Derek Parnell's unnamed markup language</a>. Here is the Grammar for Labelled S-Expressions in Extended Backus-Naur Form (EBNF):

<pre>
  document ::=
    tagged_content

  tagged_content ::=
    "(" text ":" content ")"

  content ::=
    text? (tagged_content | text)*

  text ::=
    (^("(" | ":" | ")" | "'") | escaped_char)+

  escaped_char ::=
    "'" .
</pre>

And that is it, only five production rules! Encoding is UTF-8.

<h3>Design Goals</h3>

Labelled S-Expressions was designed so that it could be parsed as quickly as possible, and be as simple as possible,
while still maintaining usefulness as a portable text-based data format.

<h3>Parser</h3>

The following is a snippet of C++ code for parsing labelled S-Expressions. It breaks a buffer up into nodes, where a node can either point to a label: <tt>"(xxx:"</tt> or a textual node. The input must already be validated to be a well-formed document.

<pre>
// Public Domain code by Christopher Diggins

struct lsx_node {
  lsx_node* sibling;
  lsx_node* child;
  const char* text;
};

lsx_node* lsx_parse(const char** pp) {
  if (**pp == ')') {
    ++*pp;
    return NULL;
  }
  lsx_node* node = (lsx_node*)calloc(sizeof(lsx_node), 1);
  node-&gt;text = *pp;
  if (**pp == '(') {
    ++*pp;
    while (*(*pp)++ != ':') {
      if (**pp == '\'') ++*pp;
    }
    node-&gt;child = lsx_parse(pp);
    lsx_node* child = node-&gt;child;
    while (child != NULL) {
      child-&gt;sibling = lsx_parse(pp);
      child = child-&gt;sibling;
    }
  }
  else {
    while ((**pp != '(') &amp;&amp; (**pp != ')')) {
      if (**pp == '\'') ++*pp;
      ++*pp;
    }
  }
  return node;
}
</pre>
<h3>Checking Well-Formedness</h3>

Here is a function for checking well-formedness and returns the number of nodes in the data:

<pre>
// Public Domain code by Christopher Diggins
// returns the number of lsx_nodes
// and returns 0 if document is ill-formed

int lsx_node_count(const char* p) {
  int ret = 0;
  int match = 0;
  if (*p == NULL) return 0;
  while (*p != NULL) {
    switch (*p) {
      case '(' :
        ++ret;
        ++match;
        while (*p != ':') {
          if (*p == NULL) return 0;
          if (*p == '\'') ++p;
          if (*p == NULL) return 0;
          ++p;
        }
        ++p;
        break;
      case ')' :
        --match;
        ++p;
        break;
      case ':' :
        return 0;
      default:
        ++ret;
        while ((*p != '(') &amp;&amp; (*p != ')') &amp;&amp; (*p != ':'))  {
          if (*p == NULL) return 0;
          if (*p == '\'') ++p;
          if (*p == NULL) return 0;
          ++p;
        }
        break;
    }
  }
  if (*p != NULL) return 0;
  if (match != 0) return 0;
  return ret;
}
</pre>
<h3>XML Converter</h3>

Here is a rudimentary XML converter for LSX data: 

<pre>
// Public Domain code by Christopher Diggins

bool lsx_is_label(lsx_node* x) {
  return (*x-&gt;text == '(');
}

std::string lsx_get_label(lsx_node* x) {
  assert(lsx_is_label(x));
  const char* p = x-&gt;text;
  while (*(++p) != ':') {
    if (*p == '\'') ++p;
  }
  return std::string(x-&gt;text + 1, p);
}

std::string lsx_get_text(lsx_node* x) {
  assert(!lsx_is_label(x));
  const char* p = x-&gt;text;
  while (*p != ')') {
    if (*p == '\'') ++p;
    ++p;
  }
  return std::string(x-&gt;text, p);
}

void lsx_output_as_xml(lsx_node* x) {
  if (x == NULL)
    return;
  if (!lsx_is_label(x)) {
    std::cout &lt;&lt; lsx_get_text(x) &lt;&lt; std::endl;
  }
  else {
    std::cout &lt;&lt; "&lt;" &lt;&lt; lsx_get_label(x) &lt;&lt; "&gt;" &lt;&lt; std::endl;
    lsx_output_as_xml(x-&gt;child);
    std::cout &lt;&lt; "&lt;/" &lt;&lt; lsx_get_label(x) &lt;&lt; "&gt;" &lt;&lt; std::endl;
  }
  lsx_output_as_xml(x-&gt;sibling);
};
</pre>
<h3>XSLT</h3>

Xml can be mapped to Labelled S-Expressions as evidenced by the following XSLT stylesheet for transforming XML into Labelled S-Expressions.

<pre>
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!-- public domain by Christopher Diggins http://www.cdiggins.com --&gt;
&lt;t:transform version="1.0" xmlns:t="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;t:output method = "html" version = "1.0" encoding = "ISO-8859-1" omit-xml-declaration = "no" standalone = "yes" indent = "yes" /&gt;

  &lt;t:template match="/"&gt;
    &lt;html&gt;
    &lt;body&gt;
    &lt;dl&gt;&lt;dt&gt;(lsx:&lt;/dt&gt;
    &lt;dl&gt;&lt;t:apply-templates/&gt;&lt;/dl&gt;
    &lt;dt&gt;)&lt;/dt&gt;&lt;/dl&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  &lt;/t:template&gt;

  &lt;t:template match="node()"&gt;
    &lt;dt&gt;(&lt;t:value-of select="name()"/&gt;:&lt;/dt&gt;
      &lt;dl&gt;&lt;t:apply-templates select="attribute::*"/&gt;&lt;/dl&gt;
      &lt;dl&gt;&lt;t:apply-templates select="child::node()"/&gt;&lt;/dl&gt;
    &lt;dt&gt;)&lt;/dt&gt;
  &lt;/t:template&gt;

  &lt;t:template match="attribute::*"&gt;
    (&lt;t:value-of select="name()"/&gt;:&lt;t:value-of select="."/&gt;)
  &lt;/t:template&gt;

  &lt;t:template match="text()"&gt;&lt;t:value-of select="."/&gt;&lt;/t:template&gt;
&lt;/t:transform&gt;
</pre>
<h3>Similar Work</h3>

There are a multitude of markup languages floating around, <a href="../_/http/www.pault.com/pault/pxml/xmlalternatives.html">
http://www.pault.com/pault/pxml/xmlalternatives.html</a> has a nice list of markup languages. I don't believe any even
come close to the simplicity and efficiency of Labelled S-Expressions.

<h1>Talk Back!</h1>
<p>
Have an opinion?


Readers have already posted

<a href="../_/https/www.artima.com/forums/flat.html$/forum=106&amp;thread=135216.html">13

comments</a>
about this weblog entry. Why not

<a href="../_/https/www.artima.com/forums/post.html$/forum=106&amp;thread=135216&amp;reply=true.html">add yours</a>?


<h1>RSS Feed</h1>
<p>
If you'd like to be notified whenever Christopher Diggins adds a new entry to <a href="../index.html$/blogger=cdiggins.html">his weblog</a>, subscribe to his <a href="../feeds/bloggers/cdiggins.rss">RSS feed</a>.

<center>
<div class="sociallinks">
<a href="../_/http/digg.com/submit$/phase=2&amp;url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D135216&amp;title=Trees+and+Labelled+S-Expressions&amp;bodytext=An+enormous+amount+of+data+can+be+conveniently+represented+as+a+labelled+tree.+This+is+the+basis+of+many+markup+languages+such+as+SGML%2C+XML%2C+HTML%2C+and+others.+Herein+I+propose+an+alternative%2C+Labelled+S-Expressions+and+provide+code+for+a+working+_&amp;topic=programming">
<img alt="Digg" border="0" height="14" hspace="8" src="../_/https/www.artima.com/images/digg.gif" width="16">Digg
  </img></a>
  |
  <a href="../_/http/del.icio.us/post$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D135216&amp;title=Trees+and+Labelled+S-Expressions">
<img alt="del.icio.us" border="0" height="16" hspace="8" src="../_/https/www.artima.com/images/delicious.gif" vspace="1" width="16">del.icio.us
  </img></a>
  |
  <a href="../_/http/programming.reddit.com/submit$/url=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D135216&amp;title=Trees+and+Labelled+S-Expressions">
<img alt="Reddit" border="0" height="18" hspace="8" src="../_/https/www.artima.com/images/reddit.gif" width="18"/>Reddit
  </a>
</div>
</center>
<h1>About the Blogger</h1>
<p>
<table><tr valign="bottom"><td><img align="right" src="../_/https/www.artima.com/images/christopherdiggins.jpg"/></td><td>Christopher Diggins is a software developer and freelance writer. Christopher loves programming, but is eternally frustrated by the shortcomings of modern programming languages. As would any reasonable person in his shoes, he decided to quit his day job to write his own ( <a href="../_/http/www.heron-language.com/index.html">www.heron-language.com</a> ). Christopher is the co-author of the <a href="../_/http/www.cpp-cookbook.com/index.html">C++ Cookbook</a> from O'Reilly. Christopher can be reached through his home page at  <a href="../_/http/www.cdiggins.com/index.html">www.cdiggins.com</a>.</td></tr></table><p>
<div class="sp">This weblog entry is Copyright © 2005 Christopher Diggins. All rights reserved.</div>
</p></p></p></p></p></p></div>

<hr width="100%">
<table align="center" width="50%">
<tr>
<td>
<div class="horizontaltextadbox">
<div class="adheadline">Sponsored Links</div>
<div id="sponsoredlinks">
</div>
</div>
</td>
</tr>
</table>
<hr width="100%"/>
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script src="../_/https/pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript">
</script>
<br>
<br/>
<!-- SiteSearch Google -->
<form action="../_/https/www.google.com/custom/index.html" method="get">
<table bgcolor="#ffffff" border="0">
<tr><td align="left" height="32" nowrap="nowrap" valign="top">
<a href="../_/https/www.google.com/index.html">
<img alt="Google" border="0" src="../_/https/www.google.com/logos/Logo_25wht.gif"/></a>
</td>
<td nowrap="nowrap">
<input name="domains" type="hidden" value="Artima.com"/>
<input maxlength="255" name="q" size="31" type="text" value=""/>
<input name="sa" type="submit" value="Search"/>
</td></tr>
<tr>
<td> </td>
<td nowrap="nowrap">
<font color="#000000" size="-1">
<input name="sitesearch" type="radio" value=""/> Web
<input checked="checked" name="sitesearch" type="radio" value="Artima.com"/>Artima.com
</font>  
<input name="client" type="hidden" value="pub-3911176865765226"/>
<input name="forid" type="hidden" value="1"/>
<input name="ie" type="hidden" value="ISO-8859-1"/>
<input name="oe" type="hidden" value="ISO-8859-1"/>
<input name="cof" type="hidden" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;"/>
<input name="hl" type="hidden" value="en"/>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</br></center>
<br/>
<div class="sp">
<div style="text-align: center;">
<a href="../_/https/www.artima.com/copyright.html">Copyright</a> © 1996-2019 Artima, Inc. All Rights Reserved. - <a href="../_/https/www.artima.com/privacy.html">Privacy Policy</a> - <a href="../_/https/www.artima.com/termsofuse.html">Terms of Use</a>
</div>
</div>
<br/>
<script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = '../_/https/www.artima.com/zcr/index.html' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(3);
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('leftskyscraper');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>
</hr><a href="https://dafoster.net/projects/crystal-web-archiver/" id="cr-footer-banner" style="border-top: 2px #B40010 solid;background: #FFFAE1;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant: initial;font-weight: initial;text-transform: none;font-size: 14px;color: #6c757d;line-height: 2.0;cursor: pointer;display: flex;align-items: center;justify-content: center;gap: 4px;clear: both;" target="_blank"><img height="24" onerror="this.style['display'] = 'none';" src="../_/crystal/resources/appicon.png" width="24"/><span>This page was archived with Crystal</span><script>window.addEventListener('load', function() { const $1 = document.querySelector('#cr-footer-banner'); if (!$1) { return; } if (window !== window.top) { let $2 = false; if (window.name) { const $3 = window.parent.document.getElementsByName(window.name); if ($3.length === 1) { const $4 = $3[0]; if ($4.tagName === 'FRAME' && $4.parentElement.tagName === 'FRAMESET') { let $5 = $4; while (true) { if ($5.parentElement.tagName !== 'FRAMESET') { $2 = true; break; } if ($5.parentElement.attributes['rows'] !== undefined) { const $6 = $5.parentElement.children; if ($5 === $6[$6.length - 1]) { $5 = $5.parentElement; continue; } else { break; } } else if ($5.parentElement.attributes['cols'] !== undefined) { const $7 = Array.from($5.parentElement.children); const $8 = $7.indexOf($5); if ($8 === -1) { break; } const $9 = $5.parentElement.attributes['cols'].value.split(','); const $10 = $9.map((s) => parseInt(s.trim())); if ($9[$8].trim() === '*' || $10[$8] === Math.max.apply(null, $10)) { $5 = $5.parentElement; continue; } else { break; } } else { break; } } } } } if (!$2) { $1.style['display'] = 'none'; } } const $11 = $1.getBoundingClientRect(); const $12 = ($11.y < window.innerHeight - $11.height); if ($12) { $1.style['position'] = 'fixed'; $1.style['bottom'] = '0'; $1.style['left'] = '0'; $1.style['right'] = '0'; $1.style['z-index'] = '9999'; } const $13 = ( document.body.getBoundingClientRect().height < $11.height * 2 ); if ($13) { $1.style['display'] = 'none'; }
});</script></a></body>
</html>
